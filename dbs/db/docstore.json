[["0",{"pageContent":"Ben Evans\nJava: The Legend\nPast, Present, and Future","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":5,"lines":{"from":1,"to":3}}}}],["1",{"pageContent":"978-1-491-93467-8\n[LSI]\nJava: The Legend\nby Ben Evans\nCopyright © 2015 O’Reilly Media, Inc. All rights reserved.\nPrinted in the United States of America.\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA\n95472.\nO’Reilly books may be purchased for educational, business, or sales promotional use.\nOnline  editions  are  also  available  for  most  titles  (http://safaribooksonline.com).  For\nmore     information,     contact     our     corporate/institutional     sales     department:\n800-998-9938 or corporate@oreilly.com .\nEditor: Nan Barber\nProduction Editor: Nicholas Adams\nProofreader: Nicholas Adams\nInterior Designer: David Futato","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":6,"lines":{"from":1,"to":16}}}}],["2",{"pageContent":"Cover Designer: Karen Montgomery\nIllustrator: Anna Evans\nSeptember 2015:\n First Edition\nRevision History for the First Edition\n2015-09-22:    First Release\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Java: \nThe Legend,\nthe cover image, and related trade dress are trademarks of O’Reilly Media, Inc.\nWhile  the  publisher  and  the  author  have  used  good  faith  efforts  to  ensure  that  the\ninformation and instructions contained in this work are accurate, the publisher and\nthe author disclaim all responsibility for errors or omissions, including without limi‐\ntation responsibility for damages resulting from the use of or reliance on this work.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":6,"lines":{"from":17,"to":29}}}}],["3",{"pageContent":"Use of the information and instructions contained in this work is at your own risk. If\nany  code  samples  or  other  technology  this  work  contains  or  describes  is  subject  to\nopen source licenses or the intellectual property rights of others, it is your responsi‐\nbility to ensure that your use thereof complies with such licenses and/or rights.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":6,"lines":{"from":30,"to":33}}}}],["4",{"pageContent":"Table of Contents\nPreface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   ix\n1.History and Retrospective. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    1\nThe High-Level Design of Java                                                           1\nA Brief History of Java                                                                         2\nHistory of Open-Source Java                                                              4\nThe Age of Oracle                                                                                 7","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":7,"lines":{"from":1,"to":7}}}}],["5",{"pageContent":"Retrospective                                                                                         9\n2.The Java Language. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    11\nPrimary Java Language Design Goals                                              11\nLanguage and VM Initially Influenced Each Other                      15\nLibraries                                                                                               15\nRecent Developments                                                                        17\nJava’s Greatest Hits                                                                              19","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":7,"lines":{"from":8,"to":14}}}}],["6",{"pageContent":"The Java Hall of Heroic Failure                                                        21\nConclusion                                                                                          23\n3.\nThe Java Virtual Machine and Platform. . . . . . . . . . . . . . . . . . . . . . . .   25\nThe Design of the JVM                                                                      26\nSelf-Management                                                                                30\nBeyond Java                                                                                         32\nConclusion                                                                                          34\n4.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":7,"lines":{"from":15,"to":23}}}}],["7",{"pageContent":"Java Developers and the Ecosystem. . . . . . . . . . . . . . . . . . . . . . . . . . .    35\nOverview of the Java Ecosystem                                                       35\nThe Java Community Process                                                           36\nvii","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":7,"lines":{"from":24,"to":27}}}}],["8",{"pageContent":"The Independent Java Ecosystem                                                    37\nThe Java Community Now                                                                40\n5.The Future of Java. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   43\nJava 9                                                                                                    43\nFurther Out                                                                                         48\nConclusion                                                                                          50\nviii | Table of Contents","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":8,"lines":{"from":1,"to":7}}}}],["9",{"pageContent":"Preface\nMy first encounter with Java came as a PhD student in Spring 1998.\nI had been earning some extra money by helping a disabled student\nwho  couldn’t  physically  attend  his  first  year  Computer  Science\nclasses.  I’d  learned  Dijkstra’s  algorithm  and  enough  graph  theory  to\nstay  ahead  of  the  class,  and  at  the  end  of  term,  he  came  to  me  and\nasked if I’d sit in on another class for him—some new programming\nlanguage called “Java.”\nAt  first  I  refused,  but  I  eventually  relented,  and  I  clearly  remember\nmany a late night sitting by the Physics department printer, waiting\nfor a print-out of some tutorials and early javadoc so I could read up\nbefore the class.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":9,"lines":{"from":1,"to":12}}}}],["10",{"pageContent":"Little did I know that this language and environment would have the\nimpact on my life and career that it has.\nAcknowledgements\nThanks to my wife Anna Evans for the illustrations, to Samir Talwar,\nHelen Scott, and Gil Tene for technical reviews. To Dalibor Topic for\ncorrecting   the   timeline   of   events   leading   up   to   the   release   of\nOpenJDK.  To  the  O’Reilly  team:  Nan  Barber,  Brian  Foster,  Heather\nScherer,  and  Megan  Blanchette.  Finally  to  Mike,  who  was  responsi‐\nble for getting me into this industry in the first place (if you’re read‐\ning this, please contact O’Reilly, and they’ll reconnect us).\nix","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":9,"lines":{"from":13,"to":23}}}}],["11",{"pageContent":"CHAPTER 1\nHistory and Retrospective\nThe  first  public  release  of  Java  was  May  23,  1995,  as  an  alpha  avail‐\nable only on Sun Microsystem’s Solaris operating system. Since that\nfirst release, Java has developed into one of the world’s most widely\ndeployed  programming  environments.  It  has  gained  traction  and\nmarket  share  in  essentially  every  programming  environment,  espe‐\ncially enterprise software, server-side Web development, and mobile\nphone programming.\nJava is a blue collar language. It’s not PhD thesis material but a lan‐\nguage for a job.\n—James Gosling\nIt  has  been  a  long  journey  with  many  surprises  along  the  way.  That","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":11,"lines":{"from":1,"to":13}}}}],["12",{"pageContent":"journey  started  in  the  early  days  with  James  Gosling  and  his  team,\nwho  were  sure  that  developers  wanted  advanced  productivity  fea‐\ntures  (such  as  object  orientation  and  garbage  collection),  but  felt\nthat  many  engineers  were  scared  off  by  the  complexity  of  the  lan‐\nguages that implemented them.\nThe High-Level Design of Java\nIn  language  design  terms,  Java  has  always  been  based  on  a  number\nof  deliberate,  opinionated  design  decisions  with  specific  goals  in\nmind.  The  Java  platform’s  initial  primary  goals  can  be  summed  up\nas:\n•\nTo  provide  a  container  for  simple  execution  of  object-oriented\napplication code\n1","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":11,"lines":{"from":14,"to":27}}}}],["13",{"pageContent":"•To  remove  tedious  bookkeeping  from  the  hands  of  developers\nand make the platform responsible for accounting for memory\n•To  remove  C/C++  platform  security  vulnerabilities  wherever\npossible\n•To allow cross-platform execution\nNotably,  these  goals  were  pursued  even  at  the  expense  of  low-level\ndeveloper control and performance cost in the early years.\nBy  almost  completely  eliminating  the  cost  of  porting,  Java  allowed\ndevelopers to focus on solving business problems.\n—Georges Saab\nThe portability goal was enthusiastically referred to as “Write Once,\nRun  Anywhere”  (WORA).  It  represents  the  idea  that  Java  class  files","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":12,"lines":{"from":1,"to":12}}}}],["14",{"pageContent":"could  be  moved  from  one  execution  platform  to  another  and  run\nunaltered. It relies on the existence and availability of a Java Virtual\nMachine  (JVM)  for  the  host  platform.  Porting  Java  to  a  new  plat‐\nform thus becomes a matter of implementing a JVM that will run on\nthe  new  platform  in  accordance  with  the  virtual  machine  specifica‐\ntion (usually called the VMspec).\nA Brief History of Java\nThe world that Java arrived into was very different to the one we live\nin  today.  Microsoft  was  counting  down  to  their  August  release  of\nWindows  95  (which  would  launch  without  a  Web  browser).  Net‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":12,"lines":{"from":13,"to":22}}}}],["15",{"pageContent":"scape   was   yet   to   go   public   (IPO)   on   the   NASDAQ   exchange,\nalthough  its  browser  was  steadily  gaining  in  popularity.  The  Inter‐\nnet, as a whole, was yet to truly enter the public consciousness.\nAs a harbinger of things to come, Sun’s initial release of the Java lan‐\nguage was accompanied by HotJava, a browser intended to compete\nwith the then-dominant Mosaic browser, and to supercede it via the\nintroduction of richer, dynamic applications using Java’s applet tech‐\nnology. Despite this, few could have predicted the impact that Java’s\nseemingly modest release would ultimately have.\nRapidly growing public interest in the Internet, fueled by Netscape’s","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":12,"lines":{"from":23,"to":32}}}}],["16",{"pageContent":"IPO and other market events, produced conditions that kicked off a\nfirst wave of enthusiasm (and more than a little hype) for Java. This\nwould ultimately lead to some surprising consequences, not least of\nwhich was the renaming of an unrelated scripting language to “Java‐\n2 | Chapter 1: History and Retrospective","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":12,"lines":{"from":33,"to":37}}}}],["17",{"pageContent":"script”  in  order  to  cash  in  on  the  public  profile  of  the  Java  ecosys‐\ntem.\nSince  those  early,  heady  days,  Java  has  had  a  fairly  conservative\ndesign philosophy and an often-mocked slow rate of change. These\nattributes,   however,   have   an   overlooked   flip   side—a   conscious\nattempt  to  protect  the  investment  of  businesses  that  have  adopted\nJava technology.\nAfter the USENIX session in which James Gosling first talked pub‐\nlicly about Java, people were already dancing on Java’s grave.\n—Mike Loukides\nNot only that, but Gosling’s vision has been more than vindicated—\nthe  design  decisions  of  Java’s  early  days  are  now  considered  uncon‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":13,"lines":{"from":1,"to":12}}}}],["18",{"pageContent":"troversial. This provides a clear example of the old software maxim\nthat “the most hated programming languages are inevitably the most\nwidely  used.”  In  Java’s  case,  that  extends  to  the  plagiarism  of  Java’s\nideas and design principles.\nAs  one  example,  very  few  application  developers  would  even  try  to\ndefend the opinion that memory should be managed by hand these\ndays.  Even  modern  systems  programming  languages,  such  as  Go\nand  Rust,  take  it  as  a  given  that  the  runtime  must  manage  memory\non behalf of the programmer.\nThe  Java  language  has  undergone  gradual,  backwards-compatible","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":13,"lines":{"from":13,"to":22}}}}],["19",{"pageContent":"revision  but  no  complete  rewrites.  This  means  that  some  of  Java’s\noriginal  design  choices,  made  out  of  expediency  due  to  the  restric‐\ntions  and  conventions  of  late  90s  technology,  are  still  constraining\nthe platform today.\nThe  early  years  of  the  21st  century  saw  the  rise  of  Enterprise  Java,\npushed  heavily  by  Sun  (and  later  Oracle)  as  the  future  way  to\ndevelop  applications.  Initial  versions  of  the  platform  (known  origi‐\nnally as J2EE, and more recently as Java EE) were criticized for per‐\nformance  and  complexity  problems.  However,  despite  these  issues,\nthe use of Java in enterpises continuedcto grow at a rapid rate.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":13,"lines":{"from":23,"to":32}}}}],["20",{"pageContent":"Eventually, more lightweight frameworks (e.g., Spring) emerged. As\nthese  challengers  added  features,  they  inevitably  grew  in  size  and\ncomplexity.  At  the  same  time,  the  Java  EE  standards  progressed,\nshedding  unecessary  layers  of  configuration,  and  began  to  focus  on\nthe core needs of developers inside the enterprise.\nA Brief History of Java | 3","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":13,"lines":{"from":33,"to":38}}}}],["21",{"pageContent":"Today,  the  enterprise  space  remains  vibrant,  with  healthy  competi‐\ntion  between  different  frameworks  and  approaches  to  large-scale\ndevelopment. In the last 10 years, only Microsoft’s .NET framework\nhas  offered  any  serious  competition  to  Java  for  enterprise  develop‐\nment.\nMeanwhile,  the  core  Java  platform  (the  “Standard  Edition,”  or  Java\nSE)  was  not  standing  still  in  the  early  part  of  the  2000s.  Java  5,\nreleased  in  2004,  was  a  significant  milestone,  and  introduced  major\nchanges to the core language. These included generic types, enumer‐\nated types, annotations, and autoboxing.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":14,"lines":{"from":1,"to":10}}}}],["22",{"pageContent":"The  standard  library  and  core  application  programming  interfaces\n(APIs)  were  also  substantially  upgraded—especially  in  the  areas  of\nconcurrent  programming  and  remote  management  (both  for  appli‐\ncations and for the JVM itself ).\nThese changes were judged to be a huge step change in Java’s evolu‐\ntion, and no release until Java 8 would have the same impact on the\nJava world. Sun also finally dropped the “Java 1.X” naming scheme,\nand started using the major number instead, so that this release was\nJava 5.\nThe  waves  of  change,  from  language  changes  in  Java  5,  to  low-level\ntechnical upgrades such as on-demand or Just-In-Time (JIT) compi‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":14,"lines":{"from":11,"to":21}}}}],["23",{"pageContent":"lation  (Java  1.3),  through  to  procedural  and  standardisation  struc‐\ntures,  such  as  the  Java  Community  Process,  or  the  Java  Language\nSpecification, have carried Java forward as a language, platform, and\necosystem.\nHistory of Open-Source Java\nThis  can  be  seen  through  the  evolution  of  Sun’s  (and  later  Oracle’s)\nattitude  to  community  and  open-source.  Despite  declaring  huge\nsupport  for  open-source,  Sun  proceeded  cautiously  where  Java’s\nintellectual property was concerned.\nThe  Java  Community  Process  (JCP)  was  set  up  by  Sun  in  1998  as  a\nway  to  bring  other  companies  and  interested  parties  into  the  devel‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":14,"lines":{"from":22,"to":32}}}}],["24",{"pageContent":"opment  process  for  Java  standards.  Sun  wanted  to  bring  potential\nrivals “inside the tent,” but didn’t want to lose control of Java in the\nprocess. The result was an industry body that represented a compro‐\nmise between competing companies that still had common cause.\n4 | Chapter 1: History and Retrospective","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":14,"lines":{"from":33,"to":37}}}}],["25",{"pageContent":"Responding to pressure from the market and the wider community,\nJonathon   Schwartz   (then   CEO   of   Sun)   announced   the   open-\nsourcing  of  Java  live  on  stage  at  JavaOne  2006.  Legend  has  it  that\nthis  announcement  was  done  without  the  full  knowledge  of  his\nmanagement  team.  This  led  to  the  creation  of  the  OpenJDK  (Open\nJava Development Kit) project in 2007, which is still responsible for\nthe  development  of  the  reference  implementation  of  the  Java  plat‐\nform today.\nSun  now  had  both  a  somewhat-open  standards  process,  and  an\nopen-source  reference  implementation  for  Java.  However,  the  path","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":15,"lines":{"from":1,"to":10}}}}],["26",{"pageContent":"to  an  open  Java  was  not  completely  smooth.  The  release  train  for\nJava 6 was already well underway, and it was felt to be too difficult to\ntry  to  move  Sun’s  toolchain  and  development  practice  over  to  an\nopen process. Instead, a drop of code from the in-development Sun\nproprietary JDK 7 was taken, scrubbed, and released as the seed for\nOpenJDK 6.\nThe release was further complicated by Sun’s decision to exempt cer‐\ntain  components  from  the  open-source  release,  citing  problems  in\nobtaining agreement from the copyright holders.\nDue to this approach, OpenJDK 6 never had a release that precisely","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":15,"lines":{"from":11,"to":20}}}}],["27",{"pageContent":"corresponded  to  a  Sun  JDK  release.  However,  the  release  train  for\nJDK 7 fixed this process, by quickly moving to an open process and\nby having all normal commits be made directly into the open repo‐\nsitories from then on. This process is still followed today.\nHistory of Open-Source Java | 5","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":15,"lines":{"from":21,"to":25}}}}],["28",{"pageContent":"Figure 1-1. The OpenJDK branching process\nFor  some  participants  in  the  open  Java  community,  Sun  did  not  go\nfar enough in open-sourcing the platform. For example, the Testing\nCompatibility Kit (TCK) was not opened, and remained proprietary\nsoftware.  This  presented  a  hurdle  for  non-Sun  implementations  of\nJava,  because  an  implementation  must  pass  100%  of  the  TCK  in\norder to be certified as a compatible implementation of Java.\nThe  Apache  Foundation  started  an  open-source,  cleanroom  imple‐\nmentation  of  Java  in  May  2005,  and  by  the  autumn  of  2006  it  had\nbecome  a  top-level  Apache  project  called  Apache  Harmony.  When","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":16,"lines":{"from":1,"to":10}}}}],["29",{"pageContent":"the  project  was  underway,  Apache  approached  Sun  for  a  TCK.\n6 | Chapter 1: History and Retrospective","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":16,"lines":{"from":11,"to":12}}}}],["30",{"pageContent":"While  not  outright  saying  “No,”  Sun  dragged  its  heels  over  the\nrequest. This was particularly true with respect to the “Field of Use”\nrestrictions  that  Sun  had  added  to  the  Java  SE  TCK  license,  which\nprevented Java SE from being legally run on a mobile phone.\nFinally, on April 10, 2007, the Apache Foundation sent an open let‐\nter to Sun demanding an open-source license for the testing kit that\nwould be compatible with the Apache license, rather than the GNU\nPublic  License  (GPL)  that  OpenJDK  uses.  Sun  did  not  produce  a\nsuitable license, and the dispute rumbled on.\nHarmony would go on to be used as the basis for Google’s Android","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":17,"lines":{"from":1,"to":10}}}}],["31",{"pageContent":"application programming framework for mobile devices. As of 2015,\nit is still the primary standard library for Android developers.\nAfter  the  release  of  Java  6  in  December  2006,  Sun  embarked  on  an\nambitious plan for Java 7, which was to grow as time passed, so that\nby late 2009 it included a proposal for some much looked-for major\nnew features.\nThese included:\n•\nLambda  expressions,  and  with  them  a  slightly  more  functional\nstyle of programming\n•\nA  completely  new  system  of  modularising  and  packagaing  Java\nclasses  to  replace  the  aging  Java  Archive  (JAR)  format  that  was\nbased upon ZIP files\n•\nA new garbage collector called Garbage First (G1)\n•","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":17,"lines":{"from":11,"to":27}}}}],["32",{"pageContent":"Enhanced support for non-Java dynamic languages running on\nthe JVM\nMany  in  the  community  began  to  question  when,  if  ever,  version  7\nwould actually arrive. However, they were soon to discover that Sun\n(and  Java  with  it)  potentially  had  far  bigger  problems  than  just  an\nendlessly slipping release date.\nThe Age of Oracle\nBy  2009  it  was  clear  that  Sun’s  revenue  and  profits  were  in  serious\ntrouble, and Sun’s Board began to seek buyers for the business. After\ntalks with IBM (and allegedly HP) failed, Oracle emerged as a buyer,\nand  made  a  substantial  offer  in  the  spring  of  2009.  Upon  obtaining\nThe Age of Oracle | 7","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":17,"lines":{"from":28,"to":39}}}}],["33",{"pageContent":"approval  from  the  US  and  EU  governments,  the  acquisition  of  Sun\nwas completed on January 27, 2010.\nThe  first  few  months  following  the  acquisition  contained  a  few\nupsets  and  high  profile  departures  from  Oracle  (including  James\nGosling,  the  original  inventor  of  Java).  Outside  of  the  Java  space,\nOracle  fared  badly,  and  was  seriously  criticized  for  its  handling  of\nsome of the open-source technologies they had acquired from Sun.\nIn  the  Java  space,  trouble  was  to  arrive  late  in  2010  when  negotia‐\ntions between Oracle and Google over licensing the Java technology\nused in Android broke down, and Oracle sued Google for copyright","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":18,"lines":{"from":1,"to":10}}}}],["34",{"pageContent":"and patent infringement.\nThe ecosystem was to receive another shock, when Apache officially\nwithdrew  its  membership  of  the  JCP  after  Oracle  refused  to  grant\nApache a TCK license for Harmony under acceptable terms, despite\nhaving  supported  Apache  against  Sun  in  the  original  dispute.  The\nHarmony  project  struggled  on  until  November  2011  before  finally\nchoosing  to  disband,  with  Android  being  the  only  real  inheritor  of\nthe technology.\nApache  has  not,  as  yet,  returned  to  the  JCP,  but  many  of  Apache’s\nprojects are implemented in Java or other JVM languages. The Ora‐\ncle/Google lawsuit was to rumble on until May 2012, when the judge","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":18,"lines":{"from":11,"to":21}}}}],["35",{"pageContent":"found decisively in favor of Google (although some minor aspects of\nthe case continue in the appeals courts).\nWith  the  effective  end  of  the  Oracle/Google  lawsuit  and  the  initial\nuncertainty  regarding  Oracle’s  stewardship  of  Java  fading,  the  Java\nplatform seems to have settled into a period of relative calm.\nOn the engineering side, this has been seen in several places—most\nclearly in that the monolithic plan for Java 7 was cut into more man‐\nageable  pieces.  First,  some  relatively  simple  features  and  internal\nengineering  work  were  shipped  as  Java  7  in  July  2011.  Next,  the\nlambda  expressions  and  functional  programming  support  followed","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":18,"lines":{"from":22,"to":31}}}}],["36",{"pageContent":"as part of Java 8 in March 2014. Finally, the long-delayed modularity\nsupport  is  intended  to  arrive  as  part  of  Java  9,  which  is  expected  to\nbe released in September 2016.\n8 | Chapter 1: History and Retrospective","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":18,"lines":{"from":32,"to":35}}}}],["37",{"pageContent":"Retrospective\nTo  conclude  this  chapter,  let’s  try  to  put  some  of  this  history  into\ncontext, remembering of course that hindsight is 20/20. Nowhere is\nthis  more  apparent  than  with  Moore’s  law,  the  hypothesis  made  by\nIntel  founder  Gordon  Moore  to  the  effect  that:  “The  number  of\ntransistors on a mass-produced chip roughly doubles every 2 years.”\nThis  phenomenon,  representing  an  exponential  increase  in  com‐\nputer  capability  since  1965,  has  had  transformative  effects  on  com‐\nputing (and knock-on effects to human society). Java has been a par‐\nticularly  fortunate  beneficiary  of  the  availability  of  an  increasing\namount of computer power.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":19,"lines":{"from":1,"to":11}}}}],["38",{"pageContent":"Software is eating the world.\n—Marc Andreessen\nLong  term  bets  in  software  have  always  been  notoriously  difficult.\nFor  example,  the  decisions  made  by  many  national  governments  to\nstandardize on Microsoft in the early 90s proved to be exceptionally\nexpensive, and provided a very powerful advantage to the vendor in\nwinning additional work.\nJava  has  benefited  from  some  early  design  decisions,  that  could  be\nseen  either  as  prescient  or  very  lucky.  The  WORA  approach  pro‐\nvided a platform-neutral approach at a time when few predicted that\nthe  Intel  family  of  chip  designs  would  become  dominant  across","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":19,"lines":{"from":12,"to":22}}}}],["39",{"pageContent":"essentially  the  entire  industry.  It  also  protected  Java  from  being\nlocked in to a single operating system.\nMoore’s  law  also  aided  Java  by  providing  a  free  lunch  in  terms  of\ncomputing capability. The processor intensive aspects of the modern\nJava  platform,  such  as  Profile  Guided  Optimization  (PGO)  and  JIT\ncompilation,  are  only  possible  because  of  the  incredible  growth  in\npower of processors.\nThe   Java   design   principle   of   backwards   compatibility   has   also\nproved  to  be  very  helpful  to  Java.  Large  companies  have  felt  confi‐\ndent about investing in Java as a platform in part because of the visi‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":19,"lines":{"from":23,"to":32}}}}],["40",{"pageContent":"ble  commitment  to  maintaining  older  versions  and  not  breaking\nworking code by platform upgrades.\nJava  has  also  been  less  fortunate  in  some  areas,  partially  because  of\nits  early  success.  Many  large,  slow  moving  organizations  (including\nRetrospective | 9","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":19,"lines":{"from":33,"to":37}}}}],["41",{"pageContent":"more  than  a  few  governments)  adopted  Java  applets  as  a  standard\ntechnology for accessing systems over the Web.\nApplets are a technology that are very much of their time, and they\nhave  not  aged  well.  The  technology  proved  to  be  very  difficult  to\nevolve,  and  so  applets  have  not  been  considered  to  be  a  modern\ndevelopment platform for many years now. However, they doggedly\npersist  due  to  some  large  early  adopters  being  very  resistant  to\nchange. The resulting effect to the ecosystem is that Java applets are\nstill present in the platform, and are a major contributor to security\nproblems.\nAs we reach Java’s 20th birthday, some observers have begun to talk","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":20,"lines":{"from":1,"to":11}}}}],["42",{"pageContent":"of  “the  second  age  of  Java.”  Java’s  high  performance,  stability,  and\nlarge  numbers  of  developers  are  making  it  an  attractive  choice  for\nmany  software  projects.  Not  only  that,  but  many  of  the  most  inter‐\nesting  new  languages  (such  as  Clojure  and  Scala)  are  implemented\non top of the JVM.\nWill  Java  be  around  in  a  recognisable  form  for  its  30th  (or  40th)\nbirthday? The future is, of course, uncertain, but on the current evi‐\ndence, it seems entirely possible.\n10 | Chapter 1: History and Retrospective","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":20,"lines":{"from":12,"to":20}}}}],["43",{"pageContent":"CHAPTER 2\nThe Java Language\nIn  this  chapter,  I’ll  discuss  the  Java  language,  its  evolution,  and  its\nstatus after 20 years in the field. As you’ll see, the language has with‐\nstood the test of time pretty well.\nPrimary Java Language Design Goals\nJava has a number of design goals that have formed part of the plat‐\nform since the earliest days.\nBackwards Compatibility\nThe  Java  platform  has  always  been  very  concerned  with  backwards\ncompatibility.  This  means  that  code  which  was  written  (or  even\ncompiled)  for  an  earlier  version  of  the  platform  must  continue  to\nkeep working with later releases of the platform.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":21,"lines":{"from":1,"to":13}}}}],["44",{"pageContent":"This  principle  allows  development  groups  to  have  a  high  degree  of\nconfidence  that  an  upgrade  of  their  JDK  or  JRE  will  not  break  cur‐\nrently  working  applications.  The  platform  has  been  very  successful\nin  achieving  this  and  code  written  for  Java  1.0  will  still  compile  20\nyears  later  on  a  Java  8  installation  without  modification  (in  fact,\ncompatibility  is  even  stronger  than  that,  as  you’ll  see  in  the  next\nchapter).\nBackwards compatibility is a great strength of the Java language and\nplatform,  but  in  order  to  achieve  it  some  necessary  constraints  are","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":21,"lines":{"from":14,"to":22}}}}],["45",{"pageContent":"required.  You’ll  meet  a  good  example  of  this  presently,  and  see  in\n11","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":21,"lines":{"from":23,"to":24}}}}],["46",{"pageContent":"detail how it impacted the evolution of the most recent version, Java\nSE 8.\nEasy to Learn and Read\nJava’s  approach  to  code  is  that  it  should  be  easy  to  read,  in  accord‐\nance  with  the  well-known  principle  that  code  is  read  more  often\nthan it is written.\nJava feels very familiar to many different programmers because we\npreferred tried-and-tested things.\n—James Gosling\nBy  preferring  familiar  things,  the  Java  language  aims  to  be  easy  to\nlearn and to teach. It should be no surprise that the language is one\nof the mostly widely used teaching languages in universities.\nThe  Java  language  also  promotes  the  old  adage  of  “pity  the  poor","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":22,"lines":{"from":1,"to":13}}}}],["47",{"pageContent":"maintanence programmer.” If code is read more often than it is writ‐\nten  (and  it  is),  then  comprehension  is  key  when  reading  source\ncode. This is especially true when reading code due to an outage or a\nbug.\nJava  serves  this  goal  by  providing  a  lot  of  information,  especially\nabout the type of data or objects, in the source. Some users find this\ninformation  to  be  overly  verbose  or  repetitive,  but  it  can  be  very\nhelpful, especially to newcomers, or when debugging.\nModern  development  environments  (IDEs)  also  alleviate  the  need\nfor a lot of boilerplate, by auto-generating code where possible. Still,","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":22,"lines":{"from":14,"to":23}}}}],["48",{"pageContent":"critics argue that it should be unnecessary for tools to work around\nproblems  like  this.  Whether  fully  justified  or  not,  Java’s  wordiness\nhas  become  a  part  of  the  folklore  surrounding  the  language,  to  the\nextent  that  developers  who  come  to  Java  from  other  languages  fre‐\nquently  express  surprise  that  the  verbosity  was  not  as  bad  as  it  had\nbeen portrayed.\nSimple Type System\nJava differentiates between two types of values. These are object ref‐\nerences, and the eight primitive types (boolean, byte, short, char, int,\nlong, float, and double), which are not objects but merely immutable\ndata items.\n12 | Chapter 2: The Java Language","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":22,"lines":{"from":24,"to":35}}}}],["49",{"pageContent":"This  split  is  relatively  simple,  with  the  type  system  for  objects\nbeing     single-rooted     (everything     ultimately     inherits     from\njava.lang.Object)  and  single-inherited  (every  class  has  only  one\nparent class).\nThe  split  between  references  and  primitives  in  Java’s  type  system\nrepresents something of a compromise and an accident of history.\nThe  distinction  between  objects  and  primitives  made  a  certain\namount of sense in the late 1990s when Java was developed, as per‐\nformance  of  basic  numerical  operations  was  an  important  design\ngoal.  However,  as  the  industry  developed  in  the  early  21st  century,","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":23,"lines":{"from":1,"to":10}}}}],["50",{"pageContent":"languages like Ruby and Scala proved the value of “everything is an\nobject.”  Compiler  technology  developed  to  allow  specialization  of\nobjects  to  primitives  where  possible,  providing  the  convenience  of\nobject-oriented programming with the performance of primitives.\nUnfortunately,  this  was  largely  too  late  for  Java,  as  backwards  com‐\npatibility  of  the  language  and  type  system,  and  the  sheer  volume  of\nexisting  Java  code  made  moving  to  “everything  is  an  object”  simply\nimpractical.  Java  instead  implemented  a  partial  solution—the  auto‐\nmatic “boxing and unboxing” of primitive values to objects belong‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":23,"lines":{"from":11,"to":19}}}}],["51",{"pageContent":"ing  to  a  specific  partner  class  of  each  primitive  type.  This  was  rea‐\nsonably  successful,  but  came  at  the  cost  of  additional  complexity\nand  also  exposed  previously  rather  obscure  debates  about  object\nidentity, and forced many more programmers to think about them.\nIn Java’s reference type system, the approach to object-oriented pro‐\ngramming  started  out  reasonably  simple.  All  classes  have  but  a\nsingle    parent    class,    and    all    classes    ultimately    inherit    from\njava.lang.Object.  As  this  form  of  inheritance  is  rather  inflexible,\nJava 1.0 also introduced a separate concept, the interface, which pro‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":23,"lines":{"from":20,"to":28}}}}],["52",{"pageContent":"vides a specification for functionality that a class may advertise that\nit offers.\nIf a class wants to declare that it offers functionality compatible with\nan    interface,    it    does    so    via    the    class  Foo  implements\nFunctionality construct. In Java 1.0 until Java 7, the class was then\nrequired to provide implementation code for every method declared\nin  the  interface.  Interface  files  were  not  allowed  to  provide  any\nmethod   bodies—merely   signatures   and   names   of   methods   that\nformed  part  of  the  collection  of  functionality  that  must  be  imple‐\nmented to conform to the interface.\nPrimary Java Language Design Goals | 13","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":23,"lines":{"from":29,"to":39}}}}],["53",{"pageContent":"This  model  of  types  was  significantly  extended  in  several  different\ndirections  in  Java  5.  Firstly,  the  notion  of  the  typesafe  constant,  or\nenumeration  was  introduced  via  the  enum  keyword.  This  enabled\ndevelopers  to  indicate  that  a  particular  type  only  had  a  finite  and\nknown  number  of  possible,  and  constant,  values.  This  replaced  the\nC/C++ convention of using integer constants via the typedef mech‐\nanism.\nJava’s  enum  constants  are  stronger  than  predecessors  because  they\nare  true  types  that  inherit  from  Object.  This  facility  relies  upon\nadditional  language  machinery  to  ensure  that  only  the  specified","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":24,"lines":{"from":1,"to":10}}}}],["54",{"pageContent":"instances can ever exist.\nEnums were a very useful addition to the Java type system, and rep‐\nresented a significant upgrade to previous approaches. However, it is\nimportant  to  note  that  compared  to  Scala  and  other  languages  with\nmore  advanced  type  systems,  Java  only  allows  the  representation  of\ndisjoint alternatives as instances, rather than as types.\nThe  second  addition  to  the  type  system  introduced  in  Java  5  was  a\nmetadata facility. Java developers had previously used “out of band”\ninformation,  such  as  naming  conventions  (JUnit)  or  additional\n“marker”  interfaces  (that  contained  no  methods).  Java  5  introduced","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":24,"lines":{"from":11,"to":20}}}}],["55",{"pageContent":"annotations, as a way of exhibiting additional metadata which, while\nrelevant, was essentially independent of the functionality of the type.\nThis is sometimes referred to as “orthogonal” type information.\nAnnotations  proved  to  be  a  fundamentally  different\nand new part of Java’s type system.\nAnnotations   are   fundamentally   more   flexible   than   interfaces\n(although  the  mechanism  makes  use  of  them).  Instead,  classes,\nmethods, and even packages can be annotated with additional infor‐\nmation. For example, if a method is intended to be the end point for\na  web  services  (REST)  call,  then  appropriate  information  and  sup‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":24,"lines":{"from":21,"to":30}}}}],["56",{"pageContent":"port can be provided automatically by the web container hosting the\nservice.\n14 | Chapter 2: The Java Language","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":24,"lines":{"from":31,"to":33}}}}],["57",{"pageContent":"Language and VM Initially Influenced Each\nOther\nIn the earliest days of the platform, the designs of the Java language\nand the JVM each exerted a certain degree of influence on the other.\nThis can be seen, for example, by the typing of Java bytecodes.\nThe Java language has separate primitive and reference types (which\npoint  at  objects  contained  in  Java’s  heap).  This  means  that  a  pro‐\ngrammer’s  code  should  always  know  the  type  of  any  expression.\nThis  manifests  itself  in  the  JVM—specifically  in  the  principle  that\nthe  interpretation  of  any  given  bit  pattern  differs,  depending  on\nwhether  the  pattern  has  the  type  of  an  int,  a  float,  or  a  heap","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":25,"lines":{"from":1,"to":11}}}}],["58",{"pageContent":"address.\nAccordingly,  JVM  bytecode  is  typed  and  the  types  are  essentially\nthose  of  the  Java  language.  The  result  is  that  most  JVM  bytecodes\nfall  into  “families”  that  have  several  individual  opcodes  that  deal\nwith the specific circumstances that are encountered in normal cod‐\ning.\nFor  example,  the  return  family  of  bytecodes  contains  ireturn  for  a\nmethod  that  returns  an  int,  dreturn  for  a  method  that  returns  a\ndouble,  and  areturn  for  a  method  that  returns  a  reference  (think:\n“address”).\nIn recent years, the Java language has moved from being deeply con‐\nnected with the workings of the JVM, to being “first among equals”","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":25,"lines":{"from":12,"to":23}}}}],["59",{"pageContent":"—merely the first high-level language that ran on the JVM.\nThe  most  obvious  sign  of  Java  resigning  its  privileged  place  in  the\nfirmament   of   JVM   languages   came   with   Java   7,   when   the\ninvokedynamic  bytecode  was  added  to  the  standard.  At  that  time,\nthe   reference   implementation   Java   language   compiler,   Oracle’s\njavac,  would  not  under  any  circumstances  emit  an  invokedynamic\nopcode.  Here  was  an  opcode  that  had  been  added  purely  for  the\nbenefit of non-Java languages, with no reference to Java whatsoever.\nLibraries\nNot  everything  in  language  design  is  the  language  core.  Many  fea‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":25,"lines":{"from":24,"to":33}}}}],["60",{"pageContent":"tures can be implemented in a variety of ways, and language change\nis  expensive  in  terms  of  resources.  Therefore,  wherever  possible,\nLanguage and VM Initially Influenced Each Other | 15","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":25,"lines":{"from":34,"to":36}}}}],["61",{"pageContent":"Java  has  a  principle  that  new  features  should  be  implemented  as\nlibraries.\nJava  itself,  as  a  language,  is  pretty  simple,  as  are  most  languages.\nThe real action is in the libraries, and we tried hard to have a fairly\nlarge class library straight out of the box.\n—James Gosling\nOne place in which this principle manifested itself was in the area of\narrays and collections. All programming languages need to manipu‐\nlate  data  en  masse,  and  all  languages  provide  an  assortment  of  fun‐\ndamental  data  structures  for  the  programmer  to  use  as  part  of  the\nbasic installation. Java is no exception.\nArrays and Collections","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":26,"lines":{"from":1,"to":12}}}}],["62",{"pageContent":"Java 1.0 had two different types of data structures that shipped with\nthe platform—arrays, which were provided within the syntax of the\nlanguage,  and  some  classes  (such  as  Hashtable  and  Vector)  that\nresided within the java.util package of the Java standard library.\nThis  represented  a  compromise.  Programmers  expected  a  familiar\nC-like  syntax  for  handling  arrays,  especially  arrays  of  primitive\ntypes.  On  the  other  hand,  as  heap-managed  data,  arrays  were  defi‐\nnitely  objects  in  the  Java  worldview.  This  resulted  in  a  halfway\nhouse,  where  the  object  nature  of  arrays  was  somewhat  sidelined,","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":26,"lines":{"from":13,"to":21}}}}],["63",{"pageContent":"and  set  up  a  rather  obvious  disconnect  between  seemingly  simple\narrays  and  the  object-oriented  view  contained  in  the  classes  of\njava.util.\nWith  the  arrival  of  Java  1.2  (or  Java  2  as  the  marketing  went),  Java\nreceived  a  major  upgrade  in  the  form  of  the  Java  Collections  libra‐\nries. This was a full set of data structures covering the most common\ncases,  such  as  lists,  sets,  and  maps.  However,  with  the  increased\nemphasis  on  the  object-oriented  approach,  the  split  between  arrays\nand object-based data structures became even more obvious.\nOne of the biggest changes to the language was Java Generics, which","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":26,"lines":{"from":22,"to":31}}}}],["64",{"pageContent":"appeared as a part of Java 5. Generics enable the programmer to rep‐\nresent  a  composite  type,  usually  thought  of  as  comprising  a  “con‐\ntainer”  and  “payload”  type.  Before  Java  5,  the  programmer  could\nonly  discuss  a  type  as  Box  without  any  reference  to  what  the  box\ncontained.  Using  Java  Generics,  however,  the  type  could  be  further\nqualified to Box<Egg> or Box<Wine> or Box<Shoe>. This provides for\n16 | Chapter 2: The Java Language","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":26,"lines":{"from":32,"to":38}}}}],["65",{"pageContent":"improved  safety  when  programming,  as  the  source  compiler  can\nnow detect mistaken attempts to put wine into objects that are really\nshoeboxes or eggboxes.\nRecent Developments\nThe last few releases of Java have seen some steps in the direction of\nmaking Java require less boilerplate code.\nReducing Verbosity—Java 7\nFirst,  in  Java  7,  the  notion  of  type  inference  was  introduced.  Previ‐\nously,  javac  would  require  the  poor  programmer  to  write  out  type\ninformation in excruciating detail:\nMap<String, String> enToFrDict = new HashMap<String, String>();\nThe  arrival  of  Java  7  allowed  programmers  to  make  some  modest\nsavings of keystrokes:","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":27,"lines":{"from":1,"to":13}}}}],["66",{"pageContent":"Map<String, String> enToFrDict = new HashMap<>();\nwith  the  type  information  of  the  generics  being  ommitted  on  the\nright-hand side.\nAnother  place  where  the  type  information  was  used  to  condense\ncode was in the feature called multicatch. Java contains a concept of\nan exception, which is used to indicate that an unexpected condition\nhas  been  encountered.  Operations  such  as  file  handling  may  result\nin  a  number  of  different  possible  error  conditions  (file  not  found,\npermission  denied,  etc.)  occuring.  Java  therefore  allows  multiple\nrecovery  strategies  (called  “catch  blocks”)  to  be  specified,  with  the","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":27,"lines":{"from":14,"to":23}}}}],["67",{"pageContent":"strategy executed chosen based on the type of problem experienced.\nIn  Java  6  and  earlier,  each  catch  block  must  be  specified  separately,\npossibly leading to a lot of repeated code:\ntry {\n   // Try to read a class file from disc, classload it to\n   // get a class object and then access a method reflexively.\n   //\n   // This process can fail in a number of different ways...\n} catch (IOException iox) {\n    // ...\nRecent Developments | 17","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":27,"lines":{"from":24,"to":34}}}}],["68",{"pageContent":"} catch (InstantiationException instx) {\n    // ...\n} catch (IllegalAccessException ilax) {\n    // ...\n} catch (NoSuchMethodException nsmx) {\n    // ...\n} catch (SecurityException secx) {\n    // ...\n} catch (IllegalArgumentException ilargx) {\n    // ...\n} catch (InvocationTargetException invtx) {\n    // ...\n}\nIn Java 7 however, the language syntax was extended to allow a catch\nblock to handle several different exceptions, like this:\ntry {\n    // Same loading process\n} catch (IOException | InstantiationException\n| IllegalAccessException | NoSuchMethodException\n| SecurityException | IllegalArgumentException\n| InvocationTargetException ex) {\n    // But now we can handle all failures with a","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":28,"lines":{"from":1,"to":22}}}}],["69",{"pageContent":"// single recovery block\n}\nTowards the Future—Java 8\nOne of the most eagerly awaited features of Java 8 was the addition\nof language support for lambda expressions (aka function literals or\nclosures). Previously, Java developers had been forced to use anony‐\nmous  classes  as  a  verbose  substitute.  However,  simply  adding  the\nlanguage syntax was not the whole of the story.\n18 | Chapter 2: The Java Language","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":28,"lines":{"from":23,"to":31}}}}],["70",{"pageContent":"The overall aim was not for lambda expressions per se, but rather to\nevolve Java’s collections to allow support for “more functional” oper‐\nations,  such  as  map  and  filter.  This  was  problematic,  due  to  Java’s\nrequirement for backwards compatibility.\nOne  of  Java’s  language  constraints  that  arises  from  compatibility  is\nthat  Java  interfaces  may  not  have  new  methods  added  to  them  in  a\nnew  release  of  the  interface.  This  is  because  if  methods  were  to  be\nadded,  existing  implementations  of  the  interface  would  not  have\nthose methods. That would mean older implementations would not","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":29,"lines":{"from":1,"to":9}}}}],["71",{"pageContent":"be  seen  as  a  valid  implementation  of  the  new  version  of  the  inter‐\nface, and so binary backwards compatibility would be broken.\nThis  could  not  be  allowed  to  happen,  and  so  a  different  path  was\nchosen—allowing  an  interface  to  specify  a  default  implementation\nfor  new  methods.  With  this  change,  new  methods  can  be  added  to\ninterfaces—provided  that  they  are  default  methods.  Older  imple‐\nmentations  of  interfaces,  which  do  not  have  an  implementation  of\nthe  new  method,  simply  use  the  default  provided  by  the  interface\ndefinition.\nThis  change  had  the  side  effect  of  changing  Java’s  model  of  object-","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":29,"lines":{"from":10,"to":19}}}}],["72",{"pageContent":"oriented programming. Before Java 8, the model was strictly single-\ninherited  (for  implementation)  with  interfaces  providing  an  addi‐\ntional  way  for  types  to  express  their  compatibility  with  a  capability.\nThis was sometimes criticized for forcing types to repeat implemen‐\ntation code unecessarily.\nWith Java 8, however, Java’s model of objects changes, to allow mul‐\ntiple  inheritance,  but  only  of  implementation.  This  is  not  the  full\nmultiple  inheritance  of  state  as  implemented  by  C++  or  Scala.\nInstead, it can be thought of as essentially being a form of “stateless\ntrait” or a way to implement the mixin pattern.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":29,"lines":{"from":20,"to":29}}}}],["73",{"pageContent":"Java as a language has evolved fairly gradually, but the experiences of\nadding  lambdas  (sometimes  called  Project  Lambda  after  the  work‐\ning group that produced it) have shown us that it is entirely possible\nfor  major  changes  to  be  implemented  without  giving  up  backwards\ncompatibility or the “feel” of Java.\nJava’s Greatest Hits\nLike  most  languages,  Java  has  good  parts  and  bad  parts.  Some  of\nJava’s  successes  are  particularly  notable  and  have  been  responsible\nJava’s Greatest Hits | 19","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":29,"lines":{"from":30,"to":38}}}}],["74",{"pageContent":"for  making  Java  one  of  the  pre-eminent  programming  languages  of\nthe world.\nThreading\nJava  was  the  first  mainstream  language  to  support  threading  from\nday one. This opened the door to concurrent programming becom‐\ning a part of the mainstream of developers working lives.\nThe launch of Java coincided well with the growth of multicore sys‐\ntems.  Threaded  programs  can  scale  out  to  multiple  cores  in  a  way\nimpossible for single-threaded code.\nThreading proved to be an essential tool when developing larger and\nmore  sophisticated  systems,  from  desktop  to  server  environments.\nJava’s ground-up support for it contrasts favorably with languages in","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":30,"lines":{"from":1,"to":12}}}}],["75",{"pageContent":"which threading was an afterthought. For example, Perl’s support for\nthreading  never  really  became  stable,  and  in  the  Ruby  world,  most\ngroups  who  want  to  use  threading  prefer  the  version  of  Ruby  that\nruns on top of the JVM and uses the Java threading support (JRuby).\nLanguage Stability\nThe core Java language has evolved only modestly since the first ver‐\nsion. There are only a few keywords that have been added since the\nearliest  versions,  and  the  language  has  remained  quite  recognizable\nover  time,  with  only  the  additions  of  generics  (Java  5)  and  lambdas\n(Java 8) really changing the feel of the language.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":30,"lines":{"from":13,"to":22}}}}],["76",{"pageContent":"This has been one of the features that has made Java so popular with\nenterprises  and  larger  shops.  The  stability  has  made  it  possible  to\nbuild engineering teams with a clear roadmap of the technology, and\nfurther  speaks  to  the  aspiration  of  Java  to  be  a  technology  in  which\nordinary developers can produce business functionality.\nJava’s Type System\nJava’s type system can be characterized as:\n•\nNominal—The name of a Java type is of paramount importance.\nJava does not permit structural types in the way some other lan‐\nguages do.\n•\nStatic—All  Java  variables  have  types  which  are  known  at  com‐\npile time.\n20 | Chapter 2: The Java Language","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":30,"lines":{"from":23,"to":37}}}}],["77",{"pageContent":"•Object/Imperative—Java  code  is  object-oriented,  and  all  code\nmust  live  inside  methods,  which  must  live  inside  classes.  How‐\never, Java’s primitive types prevent adoption of the “everything is\nan object” worldview.\n•Slightly functional—Java provides support for some of the more\ncommon  functional  idioms,  but  more  as  a  convenience  to  pro‐\ngrammers than anything else.\n•\nModestly  type-inferred—Java  is  optimized  for  readability  (even\nby  novice  progammers)  and  prefers  to  be  explicit,  even  at  the\ncost of repetition of information.\n•\nStrongly  backwards  compatible—Java  is  primarily  a  business-","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":31,"lines":{"from":1,"to":13}}}}],["78",{"pageContent":"focused  language,  and  backwards  compatibility  and  protection\nof existing codebases is a very high priority.\n•\nType  erased—Java  permits  parameterized  types,  but  this  infor‐\nmation is not available at runtime.\nJava’s type system has evolved (albeit slowly and cautiously) over the\nyears and, with the addition of lambda expressions, is now on a par\nwith the type systems of other mainstream programming languages.\nLambdas,  along  with  default  methods,  represent  the  greatest  trans‐\nformation since the advent of Java 5, and the introduction of gener‐\nics, annotations, and related innovations.\nThe Java Hall of Heroic Failure","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":31,"lines":{"from":14,"to":25}}}}],["79",{"pageContent":"Java has been has been a major part of the computing landscape for\nmost  of  the  last  20  years.  In  that  time,  along  with  major  successes,\nthere  have  been  a  number  of  experiments  in  language  design  that\nhave  not  gone  as  well  as  had  been  hoped.  Long-lived  languages\ninevitably  have  warts  and  annoyances  upon  them.  For  example,  in\nJava’s case:\nJava Beans\nThis  is  the  idea  that  every  field  on  every  Java  object  should  obey  a\npublic getter and setter convention, in order to promote interopera‐\nbility  and  a  nebulous  and  poorly-conveyed  idea  of  standardization.\nThey  were  originally  felt  to  be  the  right  convention  for  handling","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":31,"lines":{"from":26,"to":36}}}}],["80",{"pageContent":"most Java objects.\nThe Java Hall of Heroic Failure | 21","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":31,"lines":{"from":37,"to":38}}}}],["81",{"pageContent":"The  term  “Java  Beans”  predates  Enterprise  Java,  and\nthey   should   not   be   confused   with   Enterprise   Java\nBeans (EJBs).\nIn  practice,  however,  the  idea  that  all  properties  should  be  mutable\nturned out to be toxic. Instead, it became clear that concurrect pro‐\ngramming  contained  a  can  of  worms  that  made  the  Java  Beans\napproach unsound for most usages.\nFinalization\nProbably  the  worst  feature  in  Java.  The  original  intention  was  to\nprovide  a  method  for  automatically  closing  resources  when  they\nwere no longer needed (in a similar spirit to the C++ RAII pattern).\nHowever,   the   mechanism   relies   upon   Java’s   garbage   collection,","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":32,"lines":{"from":1,"to":12}}}}],["82",{"pageContent":"which   is   non-deterministic.   Thus,   using   finalization   to   reclaim\nresources  is  fundamentally  unsafe  (as  the  developer  does  not  know\nhow long it will be until a resource is freed). Therefore it is impossi‐\nble to use finalization as a way of avoiding resource exhaustion, and\nthe feature cannot be fixed. In other words, never use finalization.\nInstead, Java 7 introduced “try-with-resources” as a way of automat‐\nically  controlling  and  closing  resources  that  actually  satisfies  the\nneeds of Java programmers.\nJava EE \nOver-Configuration\nEarly versions of the Java EE standards required the programmer to","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":32,"lines":{"from":13,"to":23}}}}],["83",{"pageContent":"write  an  almost  overwhelming  amount  of  configuration,  mostly  in\nXML.  This  almost  completely  obscured  the  goal  of  the  platform,\nwhich  was  to  provide  a  simple,  business-focused  environment  in\nwhich infrastructure concerns could be provided by the container.\nOver  time,  successive  versions  of  Java  EE  (as  it  is  now  known)\nreduced  the  configuration  burden,  to  the  extent  that  Java  EE7  is  a\ncompletely  modern  and  pleasant  environment  for  serverside  web\ndevelopment.  However,  the  mention  of  earlier  versions  of  Java’s\nEnterprise  Java  Beans  still  provokes  horror  from  many  older  devel‐\nopers.\n22 | Chapter 2: The Java Language","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":32,"lines":{"from":24,"to":34}}}}],["84",{"pageContent":"Threading\nJava  was  the  first  mainstream  language  to  support  threading  from\nday  one.  As  a  result,  it  was  the  proving  ground  where  many  of  the\npractical  problems  involved  in  writing  safe,  robust  concurrent  code\nwere discovered.\nThread  is  a  very  low-level  abstraction,  and  programmers  were\nexpected to manually manage concurrency in the earliest versions of\nJava.  This  improved  with  the  arrival  of  java.util.concurrent  in\nJava  5,  and  its  subsequent  development.  However,  by  that  time,\nmany  programmers  had  felt  firsthand  the  complexities  and  frustra‐\ntions of programming with Java’s threads.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":33,"lines":{"from":1,"to":11}}}}],["85",{"pageContent":"Other  languages  have  learned  from  the  pain  felt  by  the  early  pio‐\nneers  of  concurrent  programming  in  Java.  For  example,  Scala  and\nClojure  have  both  built  more  sophisticated  and  safer  constructs  on\ntop of the underpinnings provided by Java and the JVM. Elsewhere,\nthe  actor  model  and  Go’s  goroutines  have  provided  an  alternative\nview of concurrent programming.\nConclusion\nSoftware  engineering  is  a  profession  that  is  still,  despite  50  years  of\npractice,  a  very  immature  discipline.  Each  new  language  that  wants\nto be successful should strive to push the envelope of what is known","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":33,"lines":{"from":12,"to":21}}}}],["86",{"pageContent":"about software and the process of its creation. Some pushes will suc‐\nceed  and  lead  to  valuable  new  insights  into  how  programmers\nshould think about the complex domains that exist within software.\nDon’t  underestimate  the  value  of  failed  experiments,  though.  Any\nadventurous  language  with  a  significant  userbase  over  an  extended\nperiod should have plenty of warts and battle scars to its name, and\nJava is no exception.\nConclusion | 23","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":33,"lines":{"from":22,"to":29}}}}],["87",{"pageContent":"CHAPTER 3\nThe Java Virtual Machine and\nPlatform\nThe Java language drew upon many years of experience with earlier\nprogramming  environments,  notably  C  and  C++.  This  was  quite\ndeliberate, as James Gosling wanted a familiar environment for pro‐\ngrammers  to  work  within.  It  isn’t  too  much  of  an  exaggeration  to\ndescribe the Java language as “C++ simplified for ordinary develop‐\ners.”\nHowever,  Java  code  cannot  execute  without  a  Java  Virtual  Machine\n(JVM).  This  scheme  provides  a  suitable  runtime  environment  in\nwhich  Java  programs  can  execute.  Put  another  way,  Java  programs\nare unable to run unless there is a JVM available on the appropriate","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":35,"lines":{"from":1,"to":13}}}}],["88",{"pageContent":"hardware and OS we want to execute on.\nThis may seem like a chicken-and-egg problem at first sight, but the\nJVM  has  been  ported  to  run  on  a  wide  variety  of  environments.\nAnything from a TV set-top box to a huge mainframe probably has\na JVM available for it.\nIn  environments  like  Unix  and  Windows,  Java  programs  are  typi‐\ncally started by from the command line, e.g.:\njava <arguments> <program name>\nThis command starts up the JVM as an operating system process. In\nturn,  this  process  provides  the  Java  runtime  environment,  and  then\nfinally  executes  our  Java  program  inside  the  freshly  started  (and\nempty) virtual machine.\n25","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":35,"lines":{"from":14,"to":26}}}}],["89",{"pageContent":"The Design of the JVM\nThe design of the JVM also drew on the experiences of its designers\nwith  languages  such  as  C  and  C++  (but  also  more  dynamic  lan‐\nguages  such  as  Lisp  and  Smalltalk).  In  addition,  it  took  some  bold\nsteps  to  advance  the  state  of  the  computing  industry.  These  steps\nincluded the use of stack-based virtual machine technology to assist\nporting and to enable a strong security “pinch point.”\nWhen  the  JVM  executes  a  program,  it  is  not  supplied  as  language\nsource code. Instead, the source must have been converted (or com‐\npiled) into a form known as Java bytecode. The JVM expects all pro‐\ngrams to be supplied in a format called class","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":36,"lines":{"from":1,"to":11}}}}],["90",{"pageContent":"files (which always have\na  .class  extension).  It  is  these  class  files,  rather  than  the  original\nsource that are executed when a Java program runs.\nThe JVM Interpreter and Bytecode\nThe JVM specification describes how an interpreter for the bytecode\nmust  operate.  Put  simply,  it  steps  through  a  program  one  bytecode\ninstruction  at  a  time.  However,  as  Java  and  other  JVM  languages\nnatively support threading, both the JVM and the user program are\ncapable  of  spawning  additional  threads  of  execution.  As  a  result,  a\nuser program may have many different functions running at once.\nThe  Java  language  and  JVM  bytecode  have  developed  somewhat","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":36,"lines":{"from":12,"to":22}}}}],["91",{"pageContent":"separately,  and  there  is  no  requirement  for  the  two  to  exactly  repli‐\ncate  each  other.  One  obvious  example  of  this  is  what  happens  to\nJava’s  loop  keywords  (for,  while,  etc.).  They  are  compiled  away  by\njavac,  and  are  replaced  with  bytecode  branch  instructions.  In  fact,\nin  JVM  bytecode,  the  flow  control  instructions  consist  of  if  state‐\nments, jumps, and method invocation.\nFrom the bytecode perspective this is also a safety feature, as it parti‐\ntions transfer of control into local operations (essentially just if and\njmp), which can be range-checked, and non-local operations, which","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":36,"lines":{"from":23,"to":31}}}}],["92",{"pageContent":"are forced to go through the method dispatch mechanism. Nowhere\nin JVM bytecode is C’s unsafe “transfer control to arbitrary memory\naddress” construct supported.\nBytecode  also  allows  a  number  of  perfectly  legal  constructions  that\nno Java source compiler would ever emit. However, if we write byte‐\n26 | Chapter 3: The Java Virtual Machine and Platform","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":36,"lines":{"from":32,"to":37}}}}],["93",{"pageContent":"code directly we can access these capabilities and create classes with\nsome unusual properties.\nFor  example,  the  Java  language  spec  requires  that  every  class  has  at\nleast one constructor, and javac will insert a simple constructor if it\nhas been omitted. However, in raw bytecode it is completely possible\nto  write  classes  that  have  no  constructor.  Such  classes  will  be  com‐\npletely  usable  from  Java,  provided  only  static  access  to  fields  and\nmethods is used.\nThe separation was not required by either language or the JVM, but\nthe  co-evolution  of  both  aspects  means  that  there  are  areas  where","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":37,"lines":{"from":1,"to":10}}}}],["94",{"pageContent":"the  nature  of  the  JVM  “leaks  through”  into  the  Java  language,  and\nvice versa.\nInfluence of Language and VM on Each Other\nFor  example,  consider  the  insistence  of  the  Java  language  that  void\nis  not  a  type,  but  merely  represents  the  absence  of  a  return  type.\nThis  outlook  can  seem  strange  to  the  Java  beginner,  but  it  really\nstems from the design of the JVM.\nThe Java Virtual Machine is a stack machine, in the sense that each\nmethod  has  an  evaluation  stack  in  which  intermediate  results  are\nworked out before a final result is handed back to caller. To see this\nin action, consider this bit of Java code:\nclass GetSet {\n    private int one;","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":37,"lines":{"from":11,"to":23}}}}],["95",{"pageContent":"public int getOne() {\n        return one;\n    }\n    public void setOne(int one) {\n        this.one = one;\n    }\n}\nThis  Java  code,  when  compiled  with  javac,  produces  this  bytecode\nfor the getOne() method:\n  public int getOne();\n    Code:\n       0: aload_0\n       1: getfield      #2                  // Field one:I\n       4: ireturn\nThe Design of the JVM | 27","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":37,"lines":{"from":24,"to":38}}}}],["96",{"pageContent":"When executed, the aload_0 bytecode places this on the top of the\nexecution  stack.  Next,  the  getfield  opcode  consumes  the  value  of\nthe  top  of  the  stack  and  replaces  it  with  the  object  field  that  corre‐\nsponds  to  position  2  in  the  table  of  constants  (the  class’s  Constant\nPool) of this class.\nFigure 3-1. The JVM stack for getOne()\nFinally, the method explicitly returns to caller, indicating (by the ini‐\ntial letter of ireturn) that there is an int at the top of the stack that\nshould  be  collected  as  the  return  value.  This  explicitness  of  return\ntype  allows  for  more  static  checking  of  JVM  bytecode  during  class‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":38,"lines":{"from":1,"to":10}}}}],["97",{"pageContent":"loading, and helps to improve the Java security model.\nNow  consider  the  corresponding  setter  method.  This  compiles  to\nbytecode as shown:\n  public void setOne(int);\n    Code:\n28 | Chapter 3: The Java Virtual Machine and Platform","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":38,"lines":{"from":11,"to":16}}}}],["98",{"pageContent":"0: aload_0\n       1: iload_1\n       2: putfield      #2                  // Field one:I\n       5: return\nHere,  of  course,  there  is  nothing  to  return,  as  the  putfield  opcode\nconsumes  not  only  this  but  also  the  value  that  had  been  pushed\nonto  the  stack  above  it  (the  value  that  the  object  field  was  to  be  set\nto). Accordingly, the return opcode has no prefix—as the evaluation\nstack of setOne() is entirely empty.\nFigure 3-2. The JVM stack for setOne()\nThe Design of the JVM | 29","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":39,"lines":{"from":1,"to":11}}}}],["99",{"pageContent":"So,  the  Java  keyword  void  indicates  that  the  “method  returns  no\nvalue,” and it’s not a type, because it corresponds to the JVM condi‐\ntion of “method returns with the evaluation stack in an empty state.”\nThe low-level JVM design decision here mirrors the condition of the\nmethod  execution  stack  in  the  signature  of  the  high-level  language.\nJava makes this decision in preference to alternatives, such as creat‐\ning  a  specific  type  for  the  purpose  of  indicating  this  condition  (as\nScala  does  with  its  Unit  type).  This  design  decision  has  some  far-\nreaching  consequences,  especially  when  more  advanced  Java  lan‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":40,"lines":{"from":1,"to":9}}}}],["100",{"pageContent":"guage  constructs  (such  as  reflection  and  generics)  are  introduced;\nthat’s  why  language  design  is  a  complex  undertaking.  To  define  a\nlanguage feature in any given release is to open the door to uninten‐\nded  consequences  in  the  future,  when  additional  language  features\nare seen as desirable.\nDue  to  Java’s  stringent  backwards  compatibility  requirements,  these\nunknown   interactions   between   language   features   (present   and\nfuture) are a force that has driven the language to be very conserva‐\ntive.  If  the  language  has  to  maintain  perfect  consistency  when\nadopting  new  features,  then  today’s  must-have  new  feature  may  be","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":40,"lines":{"from":10,"to":19}}}}],["101",{"pageContent":"the  exact  same  thing  that  constrains  the  language  on  the  next\nrelease.\nFor  example,  Java  7  introduced  the  invokedynamic  bytecode.  This\nwas  a  big  step  in  advancing  the  JVM  and  making  it  friendlier  to\nnon-Java  JVM  languages.  It  was  introduced  into  the  platform  very\ncautiously.  The  version  of  javac  that  ships  with  Java  7  will  not,\nunder  any  circumstances,  emit  an  invokedynamic  instruction.  For\nJava  8,  the  feature  is  used  to  implement  features  related  to  lambda\nexpressions (such as default methods), but there is still no direct lan‐\nguage support for manipulating dynamic call sites.\nSelf-Management","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":40,"lines":{"from":20,"to":30}}}}],["102",{"pageContent":"There  is  another  major  aspect  of  the  JVM’s  design  that’s  not  always\nrecognized  by  beginners:  the  use  of  runtime  information  to  enable\nthe  JVM  to  self-manage,  sometimes  called  \nprofile  guided  optimiza‐\ntion (PGO).\nSoftware  research  had  revealed  that  the  runtime  behavior  of  pro‐\ngrams has a large number of potentially useful patterns that can’t be\n30 | Chapter 3: The Java Virtual Machine and Platform","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":40,"lines":{"from":31,"to":38}}}}],["103",{"pageContent":"predicted  ahead  of  time.  The  JVM  was  the  first  mainstream  plat‐\nform to try to utilize this research.\nTime and again when developers chose Java, they reaped the bene‐\nfits  of  the  implementation  continuing  to  improve  with  the  hard‐\nware  and  OS,  making  their  existing  programs  better  without  their\nhaving to lift a finger.\n—Georges Saab\nThe  JVM  collects  runtime  information  to  make  better  decisions\nabout  how  to  execute  code.  Through  this  monitoring,  the  JVM  can\noptimize   a   program   and   achieve   better   performance.   In   fact,\nmodern  JVMs  can  frequently  provide  performance  beyond  the\ncapability of platforms that don’t have PGO.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":41,"lines":{"from":1,"to":12}}}}],["104",{"pageContent":"Just-In-Time Compilation\nOne example of PGO is based on the observation that some parts of\na Java program will be called far more often than others (and some\nmethods  will  be  very  rarely,  if  ever  called).  The  Java  platform  takes\nadvantage  of  this  fact  with  a  technology  called  just-in-time  (JIT)\ncompilation.\nIn the HotSpot JVM, a profiling subsystem identifies which methods\nof the program are called most frequently. These methods are eligi‐\nble  for  compilation  into  machine  code,  which  allows  the  important\nparts of the code to achieve far higher performance than was possi‐\nble from interpreted code. In Java’s 20 year history, the optimizations","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":41,"lines":{"from":13,"to":23}}}}],["105",{"pageContent":"used  by  the  JVM  have  advanced  to  the  point  where  they  often  sur‐\npasses the performance of compiled C and C++ code.\nIn  order  to  assist  the  JIT  compiler,  the  javac  source  code  compiler\nperforms  only  very  limited  optimizations,  and  instead  produces\n“dumb  bytecode.”  This  provides  an  easy-to-understand  representa‐\ntion of the program.\nFor example, javac does not recognize and eliminate tail recursion.\nSo this code:\n    public static void main(String[] args) {\n        int i = inc(0, 1_000_000_000);\n        System.out.println(i);\n    }\n    private static int inc(int i, int iter) {\n        if (iter > 0)\n            return inc(i+1, iter-1);\nSelf-Management | 31","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":41,"lines":{"from":24,"to":39}}}}],["106",{"pageContent":"else\n            return i;\n    }\nwill  cause  a  stack  overflow  if  run.  The  equivalent  Scala  code,  how‐\never,  would  run  fine,  because  scalac  does  a  great  deal  of  optimiza‐\ntion at compile time, and will optimize away the tail recursion.\nThe general philosophy is that the JIT compiler is the part of the sys‐\ntem best able to cope with optimizing code. So javac allows the JIT\ncompiler  free  reign  to  apply  complex  optimizations  (although  this\ndoes not include tail recursion elimination).\nGarbage Collection\nThe JVM allows for automatic management of memory, via garbage\ncollection  (GC).  This  typically  runs  as  a  separate,  out-of-band  task","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":42,"lines":{"from":1,"to":13}}}}],["107",{"pageContent":"within the JVM, which user code neither knows nor cares about.\nJava’s  approach  to  GC,  at  least  in  the  Hotspot  JVM,  is  unique.  Hot‐\nspot regards collectors as pluggable systems, and out of the box the\nJVM  has  several  different  algorithms  available.  Each  of  these  is\nhighly  configurable,  and  each  has  the  ability  to  adapt  operation  to\nthe allocation behavior and other runtime conditions of the running\nJava process.\nThe  self-management  features  of  the  JVM  have  contributed  to  the\nemergence  of  highly  performant  execution  as  a  defining  feature  of\nthe  overall  Java  environment.  Gone  are  the  days  when  Java  was  the","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":42,"lines":{"from":14,"to":23}}}}],["108",{"pageContent":"punchline  of  jokes  about  poor  performance.  However,  the  JVM\nproved to have a reach and a utility outside of just Java code.\nBeyond Java\nThe  JVM  turns  out  to  be  quite  a  good  general  purpose  virtual\nmachine.   The   mixture   of   performant   primitive   operations   and\nobject orientation is a good fit for a wide range of languages.\nThere  are  versions  of  languages  such  as  Ruby,  Python,  Lisp,  and\nJavascript  that  run  on  top  of  the  JVM.  It’s  relatively  easy  to  imple‐\nment a two-level interpreter, with the language interpreter written in\nJava. Not only that, but far more sophisticated options are possible.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":42,"lines":{"from":24,"to":33}}}}],["109",{"pageContent":"For  example,  JRuby  starts  off  using  an  interpreted  mode  for  Ruby,\nbut  then  will  use  JIT  compilation  to  convert  important  methods  to\n32 | Chapter 3: The Java Virtual Machine and Platform","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":42,"lines":{"from":34,"to":36}}}}],["110",{"pageContent":"JVM  bytecode.  Eventually,  the  JVM’s  JIT  compiler  will  kick  in,  and\nthe Ruby method will be compiled to native code.\nOne of the main advantages of using the JVM as a language runtime\nis  that  it’s  easy  to  interoperate  with  Java  bytecode.  This  means  that\neach individual language need not reimplement full library support,\nbut  can  start  off  with  a  language-specific  wrapper  over  an  existing\nlibrary.  This  allows  new  JVM  languages  to  piggy-back  from  the\nestablished Java ecosystem.\nLanguages that fundamentally aim to be “a better Java,” such as Scala\nand Kotlin, require good interoperability with Java if they are to gain","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":43,"lines":{"from":1,"to":10}}}}],["111",{"pageContent":"traction and credibility. However, what is perhaps more surprising is\nhow  good  the  interoperability  story  is  for  languages  that  are  not\nvery close to Java in linguistic terms.\nFor  example,  Java  8  shipped  the  Nashorn  implementation  of  Java‐\nscript.  This  was  the  first  implementation  of  Javascript  to  hit  100%\nconformance on the ECMA standard testing kit. Despite the histori‐\ncal  accident  that  led  to  the  similarity  in  names,  Java  and  Javascript\nare  radically  different  languages.  The  fact  that  Javascript  can  be\nimplemented on top of the JVM is a huge win. This is further helped","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":43,"lines":{"from":11,"to":19}}}}],["112",{"pageContent":"by the tight integration that is available between Javascript and Java.\nIn Nashorn, every Java type is exposed via an extremely simple and\nnatural mechanism. This means that there is seamless access to all of\nJava  from  the  scripting  environment.  Not  only  that,  but  every  Java‐\nscript  function  value  can  be  used  as  a  Java  lambda  expression,  and\nvice versa.\nA very similar picture also emerges in the Clojure language. Clojure\nis  a  JVM  language  in  the  Lisp  family.  Language  pedants  may  argue\nabout  whether  Clojure  is  an  actual  Lisp,  a  Lisp  dialect,  or  merely  a\nlanguage  in  the  same  overall  diaspora.  However,  the  Lisp  nature  of","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":43,"lines":{"from":20,"to":29}}}}],["113",{"pageContent":"Clojure  is  apparent  at  first  sight.  It’s  not  necessarily  a  language  that\nwould  seem  easy  to  integrate  with  Java  at  first  sight,  since  the  type\nsystems and the feel of the languages are totally different.\nIn  both  the  Nashorn  and  the  Clojure  case,  the  language  implemen‐\ntors  have  taken  time  and  expended  effort  to  ensure  that  Java  libra‐\nries are easily accessible, and that they feel idiomatic in the language\nthat they are being transplanted into.\nSince  the  JVM  is  a  first-class  target  even  for  languages  as  different\nfrom Java as Lisp and Javascript are, it stands to reason that the JVM\nBeyond Java | 33","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":43,"lines":{"from":30,"to":39}}}}],["114",{"pageContent":"would be a good general home for programming languages. There is\nalso  a  historical  trend—with  the  release  of  Java  7,  the  specifications\nexplicitly broke the references to the Java language in the JVM spec.\nInstead, Java is now “first among equals” in terms of languages run‐\nning  on  the  JVM—a  privileged  position,  but  not  the  only  game  in\ntown.\nWe  can  see  this  in  the  way  that  invokedynamic  was  handled.  It  was\nintroduced  in  Java  7  in  order  to  help  non-Java  languages  (notably\nJRuby, although it would have been almost impossible to build Nas‐\nhorn  without  something  like  invokedynamic).  At  the  time  of  writ‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":44,"lines":{"from":1,"to":10}}}}],["115",{"pageContent":"ing,  there  are  no  plans  to  give  the  Java  language  a  way  to  directly\naccess  invokedynamic  call  sites.  Instead,  it’s  seen  more  as  a  feature\nfor library builders and non-Java languages.\nConclusion\nThe JVM has been an enormous success. Some of the design lessons\nlearned during its evolution have been widely adopted by other lan‐\nguages. Features that were once novel are now just part of the furni‐\nture  and  the  standard  toolkit  for  building  virtual  machines.  It  cer‐\ntainly  isn’t  perfect,  but  it  represents  centuries  of  engineering  effort,\nand the end result is a general purpose virtual machine that is argua‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":44,"lines":{"from":11,"to":20}}}}],["116",{"pageContent":"bly the best available target for all sorts of programming languages.\n34 | Chapter 3: The Java Virtual Machine and Platform","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":44,"lines":{"from":21,"to":22}}}}],["117",{"pageContent":"CHAPTER 4\nJava Developers and the\nEcosystem\nDon’t  listen  to  Hollywood.  That’s  good  advice  under  most  circum‐\nstances,  but  when  thinking  about  technology  it’s  particularly  true.\nThe movies would have you believing that tech is all about individ‐\nual intellectual endeavor.\nIn  fact,  the  practice  of  technology  has  always  been  a  social  activity.\nEven  before  mass  adoption  of  free  and  open-source  software,  the\nsharing of code and ideas was already a central feature of technology\nculture.\nSo it comes as no surprise that any sufficiently advanced technology\ntends  to  develop  an  ecosystem  and  community  alongside  it.  Once","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":45,"lines":{"from":1,"to":13}}}}],["118",{"pageContent":"again,  Java  is  both  unexceptional,  in  that  a  developer  ecosystem\ngrew up around it, and exceptional, because that ecosystem evolved\ninto  something  quite  unlike  any  other  language  and  platform  com‐\nmunity.\nOverview of the Java Ecosystem\nJava’s reach encompasses, by most estimates, at least 10 million pro‐\ngrammers. This gives it one of the largest and most important devel‐\noper communities of all. Only the Web/Javascript communities (and\narguably C/C++) come near to the size of the Java community.\nFor  serious,  safe  application  development,  Java  is  pretty  close  to\nbeing  the  only  game  in  town.  It’s  a  robust  and  stable  platform,  but\n35","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":45,"lines":{"from":14,"to":25}}}}],["119",{"pageContent":"despite its size and reputation for solidity, Java does, at times, suffer\nfrom an image problem. Being a competent, practical language does\nnot necessarily endear the language to people who are used to work‐\ning with it all day, every day.\nAnother  issue  is  that  Sun’s  early  marketing  material  tended  to  be\noverly  optimistic  in  promising  benefits  for  the  developer  in  some\nareas.  The  Java  developers  who’ve  been  around  since  the  early  days\nare sometimes a little cynical about the platform, and may have bat‐\ntle scars from working with early versions of the platform.\nIt’s  also  worth  remembering  that  Java  is  unashamedly  pitched  at","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":46,"lines":{"from":1,"to":10}}}}],["120",{"pageContent":"business and enterprise development. This isn’t necessarily the same\ncohort  of  freestyling  open-source  enthusiasts  that  are  sometimes\nfound  in  other  languages.  At  the  risk  of  some  stereotyping,  Java\ndevelopers are more likely to be the people who code during the day\nand  go  home  to  their  families,  rather  than  those  who  rush  off  to  a\nhackday in the evening.\nThis  can  mean  that  commentators  overlook  the  open-source  parts\nof the Java ecosystem. On the other hand, even if Java developers are\nless likely to get involved in after-hours development, the sheer size\nof  the  Java  community  means  that  there  are  still  a  large  number  of","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":46,"lines":{"from":11,"to":20}}}}],["121",{"pageContent":"developers engaged in open-source work in Java.\nThe Java Community Process\nDeveloper uptake was good in the early years after Java’s release, but\nSun  had  bigger  ambitions.  They  wanted  Java  to  become  a  wide‐\nspread standard set of technologies, but didn’t have the resources to\ndevelop  and  support  all  of  the  integrations  and  components  that\nwould  be  required  by  such  a  broad  push.  As  a  result,  Sun  needed\nadoption  of  Java  by  larger  corporations  (such  as  IBM,  Fujitsu,  and\nHP).\nMany  of  these  companies  were  concerned  by  the  rise  of  Microsoft,\nand Java technology potentially offered an opportunity to hedge that","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":46,"lines":{"from":21,"to":31}}}}],["122",{"pageContent":"risk. Sun didn’t want to cede control of Java, as it saw huge potential\nin the technology, and so created an industry body that resembled a\nstandards  body.  The  idea  was  that  standardization  would  prevent\nthe migration (followed by lock-in) of Sun’s customers to Java tech‐\nnology stacks produced by other vendors.\n36 | Chapter 4: Java Developers and the Ecosystem","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":46,"lines":{"from":32,"to":37}}}}],["123",{"pageContent":"Founded in 1998, the JCP is a way of formalising and standardising\nJava  technologies.  The  JCP  uses  Java  Specification  Requests  (JSRs),\nwhich  are  official  working  groups,  led  by  a  Specification  Lead,  that\nproduce a specification document, testing kit, and a reference imple‐\nmentation.\nThe  JCP  is  fairly  unique  in  that  it  includes  a  patent  and  intellectual\nproperty regime that protects end users and participants. To partici‐\npate  in  the  JCP,  corporations  are  required  to  provide  a  license  of\ntheir patents if they are to form part of the standards.\nA  JSR  has  a  defined  lifecycle,  whereby  the  technology  standard  is","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":47,"lines":{"from":1,"to":10}}}}],["124",{"pageContent":"worked  upon  and  guided  through  stages  of  maturity  until  it  has\nreached  the  point  where  it  is  ready  for  widespread  developer  use.\nThis  should  ensure  that  only  technologies  that  are  widely  adopted\nenough,  and  have  achieved  a  degree  of  acceptance  and  stability  are\ntargeted for standardization.\nThis  has  resulted  in  a  process  where  several  different  classes  of  JSR\nexist. For example, each new version of Java SE, EE, and ME has an\n“umbrella”  JSR  that  covers  the  content  of  the  platform  release.  The\nmost recent release of Java SE was version 8, and the corresponding\numbrella  JSR  was  JSR  337.  However,  these  umbrellas  usually  just","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":47,"lines":{"from":11,"to":20}}}}],["125",{"pageContent":"bring  together  JSRs  under  which  major  new  language  features  have\nbeen  developed.  JSR  337  therefore  included  JSR  308  (type  annota‐\ntions),  JSR  310  (new  date  and  time  libraries),  and  JSR  335  (lambda\nexpressions).\nIn  addition  to  the  umbrella  JSRs,  and  the  JSRs  dealing  with  major\nnew  features,  there  are  also  JSRs  corresponding  to  major  libraries,\nsuch  as  XML  parsing  (JSR  5)  and  servlets  (various,  latest  JSR  369).\nThere  are  also  more  niche  JSRs,  that  cater  to  a  particular  style  of\nprogramming,  such  as  the  real-time  specification  for  Java  (JSR  1).","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":47,"lines":{"from":21,"to":29}}}}],["126",{"pageContent":"Finally, the processes of the JCP itself are specified as JSRs, so occa‐\nsionally  JSRs  are  filed  to  modify  or  update  the  JSR  workflow  or\npractices of the JCP.\nThe Independent Java Ecosystem\nJava has always had an ecosystem of enthusiasts outside of Sun (and\nlater  Oracle).  In  the  early  years,  developers  wanted  to  tinker  and\nexplore  the  limitations  of  the  platform,  as  is  so  often  the  case  with\nopen-source hackers. By bumping up the edge of the possible, devel‐\nThe Independent Java Ecosystem | 37","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":47,"lines":{"from":30,"to":38}}}}],["127",{"pageContent":"opers  exposed  missing  features  that  could  be  added  into  future\nreleases, making Java even stronger.\nIn  time,  a  number  of  independent  projects  evolved,  and  even  after\nthe  open-sourcing  of  the  platform,  many  developers  chose  to  con‐\ntinue working outside of the official projects, such as OpenJDK.\nEclipse\nIBM  had  been  working  to  produce  an  IDE  for  Java,  based  on  their\nVisualAge  product.  This  led  to  the  creation  of  a  Java-based  IDE  for\nJava,  which  became  known  as  Eclipse.  In  late  2001,  IBM  released\nthis  as  open-source  code,  and  brought  together  a  consortium  of\ncompanies to steward the technology. This led to the creation of an","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":48,"lines":{"from":1,"to":11}}}}],["128",{"pageContent":"independent foundation, the Eclipse Foundation, in 2004.\nAlthough  the  IDE  product  remains  the  principal  project  for  which\nEclipse is known, the Foundation actually hosts over 200 other soft‐\nware  projects,  covering  such  areas  as  rich  client  development  and\nbusiness intelligence and reporting.\nIn  recent  years  the  Eclipse  Foundation  has  continued  to  grow  and\ndiversify,  including  to  technologies  unrelated  to  Java.  It  also  now\nhosts  a  major  project  related  to  the  emerging  software  technology\nknown as the Internet of Things (IoT).\nApache\nThe  Apache  Foundation  predates  Java.  In  fact,  its  initial  focus  was","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":48,"lines":{"from":12,"to":22}}}}],["129",{"pageContent":"the  Apache  web  server,  httpd.  Over  the  years,  Apache  expanded\noutwards from the runaway success of the web server, and became a\nbroad, language-agnostic foundation. The projects hosted under the\nbanner of the Apache Foundation cover almost every aspect of tech‐\nnology where open-source code could play a role.\nNot  only  that,  but  the  open-source  license  written  by  the  Apache\nFoundation  was  enthusiastically  adopted  by  a  large  number  of\nprojects  that  were  not  part  of,  or  governed  by  the  Apache  Founda‐\ntion.  It’s  therefore  important  to  distinguish  between  “an  Apache\nproject,”  one  that  has  been  officially  onboarded  as  part  of  the","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":48,"lines":{"from":23,"to":32}}}}],["130",{"pageContent":"Apache Foundation, and simply “an Apache-licensed project,” which\njust uses the Apache license.\nAs  Java  expanded  into  many  areas  of  enterprise  development  and\nbeyond,  it  was  inevitable  that  some  Apache  projects  would  end  up\n38 | Chapter 4: Java Developers and the Ecosystem","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":48,"lines":{"from":33,"to":37}}}}],["131",{"pageContent":"being written in Java. However, at least at first, this led to the strange\nsituation of numerous open-source libraries being written for a non-\nopen-source  platform.  Even  after  OpenJDK  became  a  reality,  the\nApache  license  and  the  GPL  license  used  by  OpenJDK  remained\nirreconcilably incompatible.\nThe response of the Apache Foundation to these licensing concerns\nwas to begin a complete compatible rewrite of the Java class libraries\n—Harmony.  Despite  being  a  qualified  technical  success,  Harmony\nwas plagued with legal problems, as discussed in Chapter 1.\nThis  culminated  in  Oracle’s  refusal  to  grant  a  TCK  licence  for  Har‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":49,"lines":{"from":1,"to":10}}}}],["132",{"pageContent":"mony.  Apache  resigned  from  the  JCP  Executive  Committee  in  pro‐\ntest  in  December  2010,  and  mothballed  Harmony  a  few  months\nlater.\nToday,  the  relationship  between  Apache  and  Oracle  is  at  a  near\nstandstill.  Java  library  projects  still  thrive  and  proliferate,  both  as\nApache-licensed  and  Apache  Foundation  projects.  However,  there\nhas  been  no  direct  rapprochement  between  the  two  sides,  and  the\nscars from the Harmony dispute are still painfully visible.\nSpring\nSun had invested heavily in a bet on the rise of Java as an enterprise\nlanguage and platform. The scope of the vision was quite ambitious,","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":49,"lines":{"from":11,"to":21}}}}],["133",{"pageContent":"aiming to largely or completely free the ordinary developer of busi‐\nness applications of low-level concerns.\nThe first few versions of the Enterprise Java vision were plagued by\nproblems.  The  most  fundamental  of  these  was  that  the  problem\nspace  was  simply  not  understood  well  enough  at  first.  Separating\nbusiness  logic  concerns  from  infrastructure,  and  separating  both\nfrom  configuration  and  deployment  is  a  worthy  goal.  However,  the\ncorrect  positioning  of  the  dividing  lines  between  these  concerns  is\nsomewhat more subtle than it seems at first glance.\nAs  a  result,  while  Java’s  footprint  in  the  enterprise  continued  to","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":49,"lines":{"from":22,"to":31}}}}],["134",{"pageContent":"grow,  teams  were  looking  for  ways  to  simplify  complexity  and  still\nprovide  more  powerful  techniques  to  define,  configure,  and  deploy\ntheir applications.\nAgainst  this  backdrop,  alternatives  to  the  official  enterprise  Java\nstacks began to emerge. One of the best known and most powerful,\nThe Independent Java Ecosystem | 39","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":49,"lines":{"from":32,"to":37}}}}],["135",{"pageContent":"was the Spring framework. This was originally created by Rod John‐\nson and first released as open-source software in 2003.\nThe initial idea behind the Spring framework was to provide a much\nmore  lightweight  way  of  configuring  and  executing  applications\nthan was possible within the orthodoxy of “pure” enterprise Java. By\nseparating  out  the  core  concern  of  configuration,  Spring  frees  the\ncontainer  from  this  responsibility.  The  design  of  Spring  allows  the\napplication  developer  to  chose  a  container  that  fits  the  needs  of  the\napplication (including not requiring a container at all).\nLike any successful technology, as users became familiar with it, they","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":50,"lines":{"from":1,"to":10}}}}],["136",{"pageContent":"started  to  discover  use  cases  that  were  not  catered  for,  and  missing\nfeatures.  Over  time,  Spring  became  a  larger  collection  of  semi-\nrelated   interoperable   technologies   that   provide   a   full-featured\nframework  of  comparable  capability  to  Java  EE.  Of  course,  catering\nto  a  larger  set  of  features  and  concerns  has  its  price.  Spring  is  now\nno longer any smaller or less complex than the technology stack that\nit was originally started in response to.\nThe   Spring   community   has   flourished   as   the   technology   has\nmatured,  and  there  are  now  numerous  Spring  developers  that  usu‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":50,"lines":{"from":11,"to":19}}}}],["137",{"pageContent":"ally,  or  exclusively,  take  the  Spring  stack  as  their  baseline  for  any\nnew   Java   development.   Outside   of   this,   Spring   has   permeated\nthroughout  the  Java  ecosystem,  and  most  working  Java  program‐\nmers will have encountered some Spring technologies at some point\nduring their career.\nThe Java Community Now\nToday’s Java community is the result of widespread developer adop‐\ntion,  corporate  politics,  global  economic  forces,  and  more  than  a\nmeasure of blind luck. Software development is increasingly global‐\nized,  but  the  simplicity  and  relatively  small  cognitive  footprint  of","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":50,"lines":{"from":20,"to":29}}}}],["138",{"pageContent":"Java  have  meant  that  the  platform  has  travelled  well  and  prospered\nas the industry has expanded.\nIn this section, we’ll look at some of the more prominent features of\nthe global Java community.\nJUGs\nJava  User  Groups  (JUGs)  are  informal  groups  of  Java  programmers\nwho  have  chosen  to  organize  into  a  loose  association  in  order  to\n40 | Chapter 4: Java Developers and the Ecosystem","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":50,"lines":{"from":30,"to":37}}}}],["139",{"pageContent":"share experience and knowledge, network, and enhance each other’s\nprofessional development.\nOracle does not enforce any particular rules on JUGs. Instead, Ora‐\ncle simply asks that when a new JUG forms, they register with Ora‐\ncle’s  community  staff.  The  company  maintains  a  list  of  groups,  and\noffers support and promotion to them.\nJUGs  are  a  great  way  to  meet  new  people,  hear  about  new  technol‐\nogy,  expand  your  skills,  get  involved  in  open-source,  and  even  find\nnew  career  opportunities.  Some  of  the  largest  and  most  influential\ngroups  include  SouJava  (Brazil)  and  the  London  Java  Community\n(UK), but there are JUGs of all sizes all over the world.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":51,"lines":{"from":1,"to":11}}}}],["140",{"pageContent":"One of the original maxims of free and open-source software is that\nall it takes is for a single developer to sit down and decide to scratch\ntheir own technical itch, and decide to share their work freely.\nDevelopers  who  come  from  a  more  corporate  background  may  not\nhave been exposed to this philosophy as much. So they may be sur‐\nprised by the small amount of work that’s required to set up a JUG,\ncollect a few Java developers together, and start making a difference.\nOne  of  the  ways  in  which  JUGs  have  started  trying  to  improve  the\necosystem is through the Adopt programs. These are JUG-led global\nprograms   founded   by   the   London   Java   Community,   and   are","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":51,"lines":{"from":12,"to":21}}}}],["141",{"pageContent":"designed to provide ways for ordinary Java developers to contribute\nto  the  development  of  new  Java  standards  (JSRs)  and  to  the  refer‐\nence  implementation  (OpenJDK).  Even  a  single,  isolated  developer\nis  welcome  to  participate,  and  can  make  a  useful  contribution\n(https://java.net/projects/adoptopenjdk).\nJava Champions\nThe  Java  Champions  program  was  started  by  Sun  to  recognize  and\nencourage  Java  professionals  working  outside  of  Sun.  While  there’s\nno precise definition, the core values are that a Champion should be\na leader, technology luminary (both in technical stature and involve‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":51,"lines":{"from":22,"to":31}}}}],["142",{"pageContent":"ment with exciting tech), and be influential, independent, and credi‐\nble to other developers.\nThe Java Champions are an exclusive group of passionate Java tech‐\nnology  and  community  leaders  who  are  community-nominated\nand selected under a project sponsored by Oracle.\n—Oracle\nThe Java Community Now | 41","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":51,"lines":{"from":32,"to":38}}}}],["143",{"pageContent":"The program contains only a few hundred expert developers world‐\nwide, and they are a diverse group, both geographically and in every\nother  regard.  They  form  an  informal  leadership  group  (along  with\nthe JUG leaders) for Java as it is practised in industry.\nThe  landscape  of  Java  developers  is  complex,  but  remains  healthy.\nThe  vast  majority  of  Java  programmers  leave  their  work  behind\nwhen they finish for the day, of course. Fortunately, the overall pool\nof  developers  is  so  big,  that  the  enthusiast,  or  person  who  wants  to\nenhance their career should find plenty of ways to engage.\n42 | Chapter 4: Java Developers and the Ecosystem","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":52,"lines":{"from":1,"to":10}}}}],["144",{"pageContent":"CHAPTER 5\nThe Future of Java\nFinally, let’s turn to the future of the language, platform, and devel‐\noper  ecosystem.  Increasingly,  these  have  become  interwoven,  so  it\nmakes sense to treat them as a whole as we look into our crystal ball.\nJava 9\nThe next major release of the platform is Java 9, scheduled for Sep‐\ntember 2016. As releases go, it’s expected to be a fairly major one, as\nit  contains  a  number  of  large  features  (although  how  their  impact\nwill compare to the arrival of lambdas in Java 8 remains to be seen).\nModules\nIf lambda expressions were the “headline” feature for Java 8, in Java\n9 it is anticipated to be modules. Up until now, the largest grouping","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":53,"lines":{"from":1,"to":13}}}}],["145",{"pageContent":"construct  for  Java  code  was  a  package,  but  the  release  of  Java  9  will\nsee  a  new  concept—the  module.  Modules  are  collections  of  code\nthat  are  larger  than  packages,  and  are  no  longer  delivered  as  JAR\nfiles (which are really just .zip files). Instead, modules have a new file\nformat that has been designed to be more efficient.\nModules also add a major new feature to the language, which is the\nability  to  enforce  access  control  across  modules.  That  is,  modules\nare able to fully specify their public API, and prevent access to pack‐\nages that are only for internal use.\nThe ability for modules to allow internals access only to trusted cli‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":53,"lines":{"from":14,"to":23}}}}],["146",{"pageContent":"ent code will have major repercussions for Java applications. This is\n43","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":53,"lines":{"from":24,"to":25}}}}],["147",{"pageContent":"most   apparent   in   the   removal   of   access   to   a   class   called\nsun.misc.Unsafe.  This  class  is  an  internal  class  (as  can  be  seen  by\nthe  fact  that  it  lives  in  a  sun  package,  rather  than  a  java  or  javax\npackage) and should not be used directly by applications or libraries.\nUnsafe  contains  functionality  that  enables  low-level  access  to  plat‐\nform features that are normally inaccessible to ordinary Java code. It\nalso  contains  code  to  directly  access  processor  features,  compare-\nand-swap  hardware  for  example.  These  capabilities  are  not  part  of\nthe  Java  standard,  yet  are  extremely  useful.  The  JDK  class  libraries","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":54,"lines":{"from":1,"to":9}}}}],["148",{"pageContent":"make  heavy  use  of  Unsafe,  especially  in  places  such  as  the  concur‐\nrency classes.\nHowever,  as  the  name  itself  suggests,  there  are  some  very  powerful\nand  potentially  damaging  methods  contained  within  Unsafe,  and  it\nhas never been standardized. So, from Java 9 onwards, this class will\nno longer be available to classes that do not form part of the JDK.\nUnfortunately, these features are very widely used by many popular\nJava  frameworks,  for  performance  or  flexibility  reasons.  So  even  if\nyour  Java  application  doesn’t  directly  call  code  from  Unsafe,  the\nchances  are  that  somewhere  in  your  stack,  you  use  a  library  that\ndoes rely on Unsafe.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":54,"lines":{"from":10,"to":20}}}}],["149",{"pageContent":"The platform needs to evolve, and the removal of access to internals\nis  a  huge  step  forward  for  writing  maintainable  and  composable\ncode.  However,  it’s  no  exaggeration  to  say  that  the  removal  of\nUnsafe  has  the  potential  to  break  every  non-trivial  Java  application\ncurrently running.\nTo   most   developers,   this   seems   like   a   backwards   incompatible\nchange.  From  Oracle’s  point  of  view,  however,  the  sun  packages  are\ninternal code, and are not guaranteed to remain unchanged. In this\nview,  libraries  and  frameworks  that  rely  on  implementation  details\nrather than public APIs do so at their own risk. This leads to a ten‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":54,"lines":{"from":21,"to":30}}}}],["150",{"pageContent":"sion  between  the  needs  of  the  core  platform,  and  the  libraries  that\nusers rely on.\nTo  resolve  this  conflict,  and  given  the  scope  and  impact  of  these\nchanges, the transition must be handled with care and clear commu‐\nnication.  Oracle  is  consulting  the  wider  community  and  at  time  of\nwriting  a  reasonable  consensus  on  how  to  proceed  seems  to  be\nemerging.\n44 | Chapter 5: The Future of Java","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":54,"lines":{"from":31,"to":38}}}}],["151",{"pageContent":"Change Default Garbage Collector\nThe  current  default  garbage  collector  is  the  parallel  collector.  The\nparallel    collector    is    extremely    efficient,    designed    for    high-\nthroughput  operation  and  uses  very  small  amounts  of  CPU  time  to\ncollect memory. However, the collector must pause the JVM to run a\ngarbage  collection  cycle  (sometimes  called  a  “Stop  The  World”\n(STW)  operation).  These  pauses  typically  last  for  up  to  a  few  hun‐\ndred milliseconds on heaps of 8 GB or less.\nIn Java 9, Oracle proposes to change the default collector to the new\nGarbage  First  (G1)  collector.  This  uses  a  more  modern  GC  algo‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":55,"lines":{"from":1,"to":10}}}}],["152",{"pageContent":"rithm that can do some of its work without pausing fully. The aim is\nto let users set “pause goals” that the JVM will try to adhere to. How‐\never,  G1  has  some  drawbacks:  it  uses  much  more  CPU  time  overall\nto collect memory, and still has the possibility of a significant pause.\nBy default, G1 will try to pause for no more than 200ms, unless nec‐\nessary, which isn’t necessarily a huge improvement over parallel.\nG1 is also lacking in real-world testing. Despite being available since\nJava  7,  relatively  few  Java  shops  have  adopted  it,  so  the  true  impact\nof changing the default collector is unknown. Applications that run","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":55,"lines":{"from":11,"to":19}}}}],["153",{"pageContent":"without an explicit choice of collector will be affected by a change of\ndefault. Limited research has been done into the percentage of appli‐\ncations that would potentially be affected, but indications are that it\ncould over 50%.\nHTTP/2\nThe HTTP/2 standard is a new version of the Web’s primary proto‐\ncol,  HTTP.  The  previous  version,  HTTP/1.1,  dates  from  1999  and\nhas  encountered  significant  problems  (such  as  head-of-line  block‐\ning)  as  the  Web  has  grown.  The  new  standard  was  created  by  the\nInternet  Engineering  Task  Force  (IETF)  HTTP  Working  Group,\nwhich   comprised   engineers   from   major   Web   companies   and\nbrowser manufacturers.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":55,"lines":{"from":20,"to":31}}}}],["154",{"pageContent":"The  basic  semantics  (including  methods)  of  HTTP\nhave  not  fundamentally  changed  in  the  new  standard,\nbut the transport mechanisms are new.\nJava 9 | 45","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":55,"lines":{"from":32,"to":35}}}}],["155",{"pageContent":"The  group  summarized  some  of  the  key  properties  of  HTTP/2  as\nfollows:\n•Same HTTP APIs\n•\nCheaper requests\n•Network- and server-friendliness\n•Cache pushing\n•\nBeing able to change your mind\n•\nMore encryption\nThe new standard is pragmatic about the way the Web has come to\nbe used; as a general purpose application protocol rather than purely\nfor  document  retrieval  and  hypertext  transfer.  So,  for  example,  in\nHTTP/2  responses  can  be  interleaved,  connections  are  not  closed\nunless  a  browser  actively  navigates  away,  and  HTTP  headers  are\nnow  represented  in  binary  to  avoid  penalizing  small  requests  and\nresponses (which is the majority of traffic).","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":56,"lines":{"from":1,"to":18}}}}],["156",{"pageContent":"In the Java world, HTTP/2 is an opportunity to revisit Java’s ancient\nHTTP API. This dates to Java 1.0 and is designed around a relatively\nprotocol-agnostic framework based on the URL class. This predates\nthe massive dominance of the Web over all other Internet protocols.\nThis  API  has  not  kept  up  with  the  reality  of  how  the  Web  is  used\ntoday.\nThe new Java API for HTTP/2 is a completely clean sheet, and aban‐\ndons  any  pretense  of  protocol  independence.  Instead,  it’s  an  API\npurely  for  HTTP,  but  is  independent  of  HTTP  version.  It  will  pro‐\nvide support for the new framing and connection handling parts of","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":56,"lines":{"from":19,"to":28}}}}],["157",{"pageContent":"HTTP/2, as well as HTTP/1.1 support for the transitional period.\nIn the current version of the new API (which may, of course, change\nbefore the release of Java 9), a simple HTTP request looks like this:\n    HttpResponse resp = HttpRequest\n        .create(new URI(\"http://www.oreilly.com\"))\n        .body(noBody())\n        .GET().send();\n    int responseCode = resp.responseCode();\n    String body = resp.body(asString());\n    System.out.println(body);\n46 | Chapter 5: The Future of Java","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":56,"lines":{"from":29,"to":39}}}}],["158",{"pageContent":"This  style  for  the  API  feels  much  more  modern  than  the  existing\nlegacy HTTP API, and reflects the trend in API design towards flu‐\nent (or builder) patterns.\nJShell\nIn  many  other  languages,  an  interactive  environment  for  explora‐\ntory   development   is   provided   via   a   Read-Evaluate-Print-Loop\n(REPL)  tool.  In  some  cases  (notably  Clojure  and  other  Lisps),  the\nREPL  is  where  developers  spend  most  of  their  coding  time.  This  is\nalso seen in languages such as Scala or JRuby.\nJava  previously  had  the  Beanshell  scripting  language,  but  it  never\nachieved  full  standardization,  and  the  project  has  essentially  been","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":57,"lines":{"from":1,"to":11}}}}],["159",{"pageContent":"abandoned. Java 8 introduced the Nashorn implementation of Java‐\nscript  on  top  of  the  JVM,  and  included  the  jjs  REPL.  Due  to\nNashorn’s tight integration with Java, this could be a useful environ‐\nment for playing with Java in an interactive manner. However, it still\nwasn’t Java.\nAs  part  of  the  development  of  Java  9,  Project  Kulla  was  started,  to\nlook at producing a Java REPL that would provide as close an expe‐\nrience  to  “full  Java”  as  possible.  The  project  had  some  strict  goals,\nsuch  as  not  to  introduce  new  non-Java  syntax.  Instead,  it  disables\nsome  features  of  the  language  that  are  not  useful  for  interactive","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":57,"lines":{"from":12,"to":21}}}}],["160",{"pageContent":"development  in  order  to  provide  a  less  awkward  working  environ‐\nment.\nIn  JShell,  statements  and  expressions  are  evaluated  immediately  in\nthe context of an execution state. This means that they do not have\nto  be  packaged  into  classes,  and  methods  can  also  be  free-standing.\nJShell  uses  “snippets”  of  code  to  provide  this  top-level  execution\nenvironment.\nIn the environment, expressions can be freely entered and JShell will\nautomatically create temporary variables to hold the resulting values\nand keep them in scope for later use:\n-> 3 * (4 + 7)\n|  Expression value is: 33\n|    assigned to temporary variable $1 of type int\n-> System.out.println($1);\n33","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":57,"lines":{"from":22,"to":36}}}}],["161",{"pageContent":"Java 9 | 47","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":57,"lines":{"from":37,"to":37}}}}],["162",{"pageContent":"New classes can easily be defined:\n-> class Pet {}\n|  Added class Pet\n-> class Dog extends Pet {}\n|  Added class Dog\nJShell also has commands, which all start with / to access REPL fea‐\ntures. For example:\n-> /help\nType a Java language expression, statement, or declaration.\nOr type one of the following commands:\n/l  or /list [all]        -- list the source you have typed\n[additional output]\n/?  or /help              -- this help message\n       /!                 -- re-run last snippet\n       /<n>               -- re-run n-th snippet\n       /-<n>              -- re-run n-th previous snippet\nSupported shortcuts include:\n<tab>       -- show possible completions for the current text","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":58,"lines":{"from":1,"to":18}}}}],["163",{"pageContent":"Just  like  REPL  environments  in  other  languages,  JShell  lets  you  use\nthe  REPL  to  demonstrate  Java  language  features  very  simply  and\nquickly.  In  turn,  this  makes  JShell  a  great  learning  tool,  similar  in\nexperience to Scala’s REPL.\nFurther Out\nOracle  does  not  release  firm  plans  more  than  one  release  ahead,\nrelying  instead  on  a  roadmap  of  features  for  future  releases.  As  a\nresult, the features and possible developments discussed in this sec‐\ntion cannot be definitively tied to any specific release.\nProject Panama\nOracle  has  already  announced  Project  Panama,  a  new  effort  to","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":58,"lines":{"from":19,"to":29}}}}],["164",{"pageContent":"define  a  Foreign  Function  Interface  (FFI)  for  the  JVM.  The  name\nevokes the Panama canal, an infrastructure project designed to link\nthe Pacific to the Atlantic. Similarly, Project Panama is about bridg‐\ning  between  the  managed  world  of  Java  and  the  unmanaged  world\nof C and other runtimes.\n48 | Chapter 5: The Future of Java","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":58,"lines":{"from":30,"to":35}}}}],["165",{"pageContent":"If  non-Java  programmers  find  some  library  useful  and  easy  to\naccess, it should be similarly accessible to Java programmers.\n—John Rose\nThe ultimate goal is to be able to directly bind native functions (such\nas the contents of shared libraries or operating-system calls) to Java\nmethods.  This  has  always  been  possible  using  Java’s  Java  Native\nInterface (JNI), but the interface is inconvenient and rather limited.\nThis  has  led  to  a  significant  barrier  to  entry  for  mixing  native  code\ninto a Java project.\nProject  Panama  has  a  difficult  task  ahead  of  it,  not  least  because\nJava’s  culture  has  always  been  about  safe  programming,  as  a  depar‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":59,"lines":{"from":1,"to":11}}}}],["166",{"pageContent":"ture  from  the  pitfalls  found  in  languages  such  as  C  and  C++.  To\nevolve Java’s access to native code without sacrificing that safety is a\nmajor undertaking, but would be of huge benefit to millions of Java\ndevelopers worldwide.\nProject Valhalla\nAnother  area  of  major  work  beyond  Java  9  is  Project  Valhalla.  This\nis an experimental project focused on new features for the Java lan‐\nguage.   Currently,   the   features   that   are   under   discussion   are\nenhanced generics and value types.\nEnhanced generics are a proposed feature that would let Java devel‐\nopers write code that uses primitive types as type parameters for col‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":59,"lines":{"from":12,"to":22}}}}],["167",{"pageContent":"lections,  such  as  List<int>.  This  is  problematic  in  the  current  lan‐\nguage and JVM because there is no type in Java that is a supertype of\nboth Object and int. That is, Java’s type system does not have a single\nroot.\nCurrently,  the  prototyping  uses  an  approach  called  “any”  type  vari‐\nables,  to  mean  that  the  type  variable  can  range  over  both  reference\ntypes  and  primitives.  However,  this  design  contains  some  subtleties\nthat  have  to  be  approached  carefully.  For  example,  List<int>  and\nList<String> could not have a supertype more specific than Object\nin Java’s existing type system.\nOne possibility is that List<Integer> and List<String> could con‐","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":59,"lines":{"from":23,"to":33}}}}],["168",{"pageContent":"tinue   to   be   represented   at   runtime   by   List.class,   but   with\nList<int>  being  represented  by  a  different  runtime  type  and  class\nfile.\nFurther Out | 49","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":59,"lines":{"from":34,"to":37}}}}],["169",{"pageContent":"The Internet of Things\nSoftware  is  not  a  static  field,  and  new  areas  of  interest  continue  to\nemerge.  One  of  the  most  eagerly  anticipated  and  hyped  is  the  so-\ncalled  Internet  of  Things  (IoT).  This  is  the  idea  that  devices  with\nvery limited compute capability compared to a laptop or phone will\nnevertheless  become  Internet-enabled  and  able  to  provide  useful\nand valuable data streams to their owners.\nJava  has  inspired  a  lot  of  hatred,  but  it’s  been  incredibly  influential\nin building modern enterprise software, along with the tools we use\nto develop, maintain, and deploy that software.\n—Mike Loukides","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":60,"lines":{"from":1,"to":11}}}}],["170",{"pageContent":"Over the years, a lot of the criticism (both justified and not) that has\nbeen  flung  in  Java’s  direction  has  abated,  replaced  by  something\ncloser to grudging, involuntary respect.\nIt is therefore not surprising that, given Java’s influence in the enter‐\nprise, application teams working towards IoT have developed stacks\nthat leverage Java’s strengths and robustness for use with a world of\ndevices possessed of limited capability.\nIt’s  still  unclear  whether  the  much-discussed  revolution  of  IoT  will\nactually take place. While the raw technology is now in place, major\nissues  such  as  security,  bandwidth,  and  data  handling  remain.  For","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":60,"lines":{"from":12,"to":21}}}}],["171",{"pageContent":"that matter, the industry has yet to decide whether a device’s “owner”\nand beneficiary of the device’s data value is the purchaser or the sup‐\nplier.\nIn  any  event,  if  the  IoT  does  become  mainstream,  then  Java  is\nextremely well-placed to become a major part of the architecture of\nthe systems that will be needed to deliver it.\nConclusion\nThe road from Java’s first public alpha of 1.0 to today has been long\nand full of technical advances and interesting adventures. Along the\nway,  Java  has  flourished,  and  has  become  one  of  the  world’s  most\nimportant and widely-used programming environments.\nHow  long  will  Java  continue  to  be  as  ubiquitous  as  it  is  today?  No-","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":60,"lines":{"from":22,"to":33}}}}],["172",{"pageContent":"one knows, but the ecosystem today is flourishing and the immedi‐\nate course that has been set seems fair. Which means, of course, that\nit’s time to raise a toast and wish Java a very Happy Birthday.\n50 | Chapter 5: The Future of Java","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":60,"lines":{"from":34,"to":37}}}}],["173",{"pageContent":"About the Author\nBen  Evans  is  the  Cofounder  and  Technology  Fellow  of  jClarity,  a\nstartup  that  delivers  performance  tools  for  development  and  ops\nteams. He helps to organize the London Java Community and repre‐\nsents  them  on  the  Java  Community  Process  Executive  Committee,\nwhere he works to define new standards for the Java ecosystem. He\nis   a   Java   Champion;   JavaOne   Rockstar;   coauthor   of   \nThe   Well-\nGrounded Java Developer and Java in a Nutshell 6E. He lives in Lon‐\ndon,  but  is  usually  found  traveling  the  world  consulting,  speaking,\nand  educating  on  the  Java  platform,  performance  analysis,  system\narchitecture, and related topics.","metadata":{"source":"/home/omar/repos/ChatPDF/app/PDFfiles/57c014f6-3263-44bb-92fb-9f24246a67fa.pdf","pdf":{"version":"1.10.100","info":{"PDFFormatVersion":"1.5","IsAcroFormPresent":false,"IsXFAPresent":false},"metadata":null,"totalPages":61},"loc":{"pageNumber":61,"lines":{"from":1,"to":12}}}}]]